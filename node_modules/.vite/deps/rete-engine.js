import {
  _get
} from "./chunk-VOQY7DP4.js";
import {
  _toConsumableArray
} from "./chunk-Y3QGWSBW.js";
import {
  NodeEditor,
  Scope,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _setPrototypeOf,
  require_regenerator
} from "./chunk-46W5G5ZB.js";
import {
  __toESM
} from "./chunk-GFT2G5UO.js";

// node_modules/rete-engine/rete-engine.esm.js
var import_regenerator = __toESM(require_regenerator());

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct3() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}

// node_modules/rete-engine/rete-engine.esm.js
var ControlFlow = function() {
  function ControlFlow2(editor) {
    _classCallCheck(this, ControlFlow2);
    _defineProperty(this, "setups", /* @__PURE__ */ new Map());
    this.editor = editor;
  }
  _createClass(ControlFlow2, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error("already processed");
      }
      this.setups.set(node.id, setup);
    }
    /**
     * Removes the node from the control flow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }
    /**
     * Execute the node and its successors (in case `forward` is called for some output).
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      var _this = this;
      var setup = this.setups.get(nodeId);
      if (!setup)
        throw new Error("node is not initialized");
      var inputKeys = setup.inputs();
      if (input && !inputKeys.includes(input))
        throw new Error("inputs don't have a key");
      setup.execute(input, function(output) {
        var outputKeys = setup.outputs();
        if (!outputKeys.includes(output))
          throw new Error("outputs don't have a key");
        var cons = _this.editor.getConnections().filter(function(c) {
          return c.source === nodeId && c.sourceOutput === output;
        });
        cons.forEach(function(con) {
          _this.execute(con.target, con.targetInput);
        });
      });
    }
  }]);
  return ControlFlow2;
}();
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ControlFlowEngine = function(_Scope) {
  _inherits(ControlFlowEngine2, _Scope);
  var _super = _createSuper$2(ControlFlowEngine2);
  function ControlFlowEngine2(configure) {
    var _this;
    _classCallCheck(this, ControlFlowEngine2);
    _this = _super.call(this, "control-flow-engine");
    _this.configure = configure;
    _this.addPipe(function(context) {
      if (context.type === "nodecreated") {
        _this.add(context.data);
      }
      if (context.type === "noderemoved") {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _createClass(ControlFlowEngine2, [{
    key: "setParent",
    value: function setParent(scope) {
      _get(_getPrototypeOf(ControlFlowEngine2.prototype), "setParent", this).call(this, scope);
      this.editor = this.parentScope(NodeEditor);
      this.controlflow = new ControlFlow(this.editor);
    }
  }, {
    key: "add",
    value: function add(node) {
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.controlflow.add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        execute: function execute(input, forward) {
          node.execute(String(input), forward);
        }
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.controlflow.remove(node.id);
    }
    /**
     * Trigger execution starting from the specified node.
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      this.controlflow.execute(nodeId, input);
    }
  }]);
  return ControlFlowEngine2;
}(Scope);
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var Dataflow = function() {
  function Dataflow2(editor) {
    _classCallCheck(this, Dataflow2);
    _defineProperty(this, "setups", /* @__PURE__ */ new Map());
    this.editor = editor;
  }
  _createClass(Dataflow2, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error("already processed");
      }
      this.setups.set(node.id, setup);
    }
    /**
     * Removes the node from the dataflow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }
    /**
     * Fetches inputs of the node.
     * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).
     * @param nodeId Node id
     * @returns Object with inputs
     */
  }, {
    key: "fetchInputs",
    value: function() {
      var _fetchInputs = _asyncToGenerator(import_regenerator.default.mark(function _callee2(nodeId) {
        var _this = this;
        var result, inputKeys, cons, inputs, consWithSourceData, _iterator, _step, _step$value, c, sourceData, previous;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                result = this.setups.get(nodeId);
                if (result) {
                  _context2.next = 3;
                  break;
                }
                throw new Error("node is not initialized");
              case 3:
                inputKeys = result.inputs();
                cons = this.editor.getConnections().filter(function(c2) {
                  return c2.target === nodeId && inputKeys.includes(c2.targetInput);
                });
                inputs = {};
                _context2.next = 8;
                return Promise.all(cons.map(function() {
                  var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(c2) {
                    return import_regenerator.default.wrap(function _callee$(_context) {
                      while (1)
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.t0 = c2;
                            _context.next = 3;
                            return _this.fetch(c2.source);
                          case 3:
                            _context.t1 = _context.sent;
                            return _context.abrupt("return", {
                              c: _context.t0,
                              sourceData: _context.t1
                            });
                          case 5:
                          case "end":
                            return _context.stop();
                        }
                    }, _callee);
                  }));
                  return function(_x2) {
                    return _ref.apply(this, arguments);
                  };
                }()));
              case 8:
                consWithSourceData = _context2.sent;
                _iterator = _createForOfIteratorHelper(consWithSourceData);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    _step$value = _step.value, c = _step$value.c, sourceData = _step$value.sourceData;
                    previous = inputs[c.targetInput] ? inputs[c.targetInput] : [];
                    inputs[c.targetInput] = [].concat(_toConsumableArray(previous), [sourceData[c.sourceOutput]]);
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                return _context2.abrupt("return", inputs);
              case 12:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function fetchInputs(_x) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches outputs of the node.
     * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.
     * @param nodeId Node id
     * @returns Object with outputs
     */
  }, {
    key: "fetch",
    value: function() {
      var _fetch = _asyncToGenerator(import_regenerator.default.mark(function _callee3(nodeId) {
        var _this2 = this;
        var result, outputKeys, data, returningKeys;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                result = this.setups.get(nodeId);
                if (result) {
                  _context3.next = 3;
                  break;
                }
                throw new Error("node is not initialized");
              case 3:
                outputKeys = result.outputs();
                _context3.next = 6;
                return result.data(function() {
                  return _this2.fetchInputs(nodeId);
                });
              case 6:
                data = _context3.sent;
                returningKeys = Object.keys(data);
                if (outputKeys.every(function(key) {
                  return returningKeys.includes(key);
                })) {
                  _context3.next = 10;
                  break;
                }
                throw new Error('dataflow node "'.concat(nodeId, `" doesn't return all of required properties. Expected "`).concat(outputKeys.join('", "'), '". Got "').concat(returningKeys.join('", "'), '"'));
              case 10:
                return _context3.abrupt("return", data);
              case 11:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
  }]);
  return Dataflow2;
}();
var Cache = function() {
  function Cache2(onDelete) {
    _classCallCheck(this, Cache2);
    _defineProperty(this, "cache", /* @__PURE__ */ new Map());
    this.onDelete = onDelete;
  }
  _createClass(Cache2, [{
    key: "get",
    value: function get(key) {
      return this.cache.get(key);
    }
  }, {
    key: "add",
    value: function add(key, data) {
      if (this.cache.has(key))
        throw new Error("cache already exists");
      this.cache.set(key, data);
    }
  }, {
    key: "patch",
    value: function patch(key, data) {
      this.cache.set(key, data);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var item = this.cache.get(key);
      this.cache["delete"](key);
      this.onDelete && this.onDelete(item);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this = this;
      Array.from(this.cache.keys()).forEach(function(item) {
        _this["delete"](item);
      });
    }
  }]);
  return Cache2;
}();
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Cancelled = function(_Error) {
  _inherits(Cancelled2, _Error);
  var _super = _createSuper$1(Cancelled2);
  function Cancelled2() {
    _classCallCheck(this, Cancelled2);
    return _super.call(this, "cancelled");
  }
  return _createClass(Cancelled2);
}(_wrapNativeSuper(Error));
function createCancellblePromise() {
  var cancelled = false;
  function commit(value) {
    if (cancelled) {
      throw new Cancelled();
    }
    return value;
  }
  var reject;
  var promise = new Promise(function(res, rej) {
    reject = rej;
    res();
  });
  for (var _len = arguments.length, sequence = new Array(_len), _key = 0; _key < _len; _key++) {
    sequence[_key] = arguments[_key];
  }
  var n = sequence.reduce(function(p, item) {
    var t = p.then(item).then(commit);
    return t;
  }, promise);
  n.cancel = function() {
    if (!cancelled)
      reject(new Cancelled());
    cancelled = true;
  };
  return n;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DataflowEngine = function(_Scope) {
  _inherits(DataflowEngine2, _Scope);
  var _super = _createSuper(DataflowEngine2);
  function DataflowEngine2(configure) {
    var _this;
    _classCallCheck(this, DataflowEngine2);
    _this = _super.call(this, "dataflow-engine");
    _defineProperty(_assertThisInitialized(_this), "cache", new Cache(function(data) {
      return (data === null || data === void 0 ? void 0 : data.cancel) && data.cancel();
    }));
    _this.configure = configure;
    _this.addPipe(function(context) {
      if (context.type === "nodecreated") {
        _this.add(context.data);
      }
      if (context.type === "noderemoved") {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _createClass(DataflowEngine2, [{
    key: "setParent",
    value: function setParent(scope) {
      _get(_getPrototypeOf(DataflowEngine2.prototype), "setParent", this).call(this, scope);
      this.editor = this.parentScope(NodeEditor);
      this.dataflow = new Dataflow(this.editor);
    }
  }, {
    key: "getDataflow",
    value: function getDataflow() {
      if (!this.dataflow)
        throw new Error("DataflowEngine isn't attached to NodeEditor");
      return this.dataflow;
    }
  }, {
    key: "add",
    value: function add(node) {
      var _this2 = this;
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.getDataflow().add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        data: function() {
          var _data = _asyncToGenerator(import_regenerator.default.mark(function _callee(fetchInputs) {
            var cache, cancellable;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    cache = _this2.cache.get(node.id);
                    if (!cache) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return", cache);
                  case 3:
                    cancellable = createCancellblePromise(function() {
                      return fetchInputs();
                    }, function(inputs) {
                      return node.data(inputs);
                    });
                    _this2.cache.add(node.id, cancellable);
                    return _context.abrupt("return", cancellable);
                  case 6:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          function data(_x) {
            return _data.apply(this, arguments);
          }
          return data;
        }()
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.getDataflow().remove(node.id);
    }
    /**
     * Resets the cache of the node and all its predecessors.
     * @param nodeId Node id to reset. If not specified, all nodes will be reset.
     */
  }, {
    key: "reset",
    value: function reset(nodeId) {
      var _this3 = this;
      if (nodeId) {
        var setup = this.getDataflow().setups.get(nodeId);
        if (!setup)
          throw "setup";
        var outputKeys = setup.outputs();
        this.cache["delete"](nodeId);
        this.editor.getConnections().filter(function(c) {
          return c.source === nodeId && outputKeys.includes(c.sourceOutput);
        }).forEach(function(c) {
          return _this3.reset(c.target);
        });
      } else {
        this.cache.clear();
      }
    }
    /**
     * Fetches input data for the node by fetching data for all its predecessors recursively.
     * @param nodeId Node id to fetch input data for
     * @throws `Cancelled when `reset` is called while fetching data
     */
  }, {
    key: "fetchInputs",
    value: function() {
      var _fetchInputs = _asyncToGenerator(import_regenerator.default.mark(function _callee2(nodeId) {
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.getDataflow().fetchInputs(nodeId));
              case 1:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function fetchInputs(_x2) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches output data of the node
     * @param nodeId Node id to fetch data from
     * @throws `Cancelled` when `reset` is called while fetching data
     */
  }, {
    key: "fetch",
    value: function() {
      var _fetch = _asyncToGenerator(import_regenerator.default.mark(function _callee3(nodeId) {
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.getDataflow().fetch(nodeId));
              case 1:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
  }]);
  return DataflowEngine2;
}(Scope);
export {
  Cancelled,
  ControlFlow,
  ControlFlowEngine,
  Dataflow,
  DataflowEngine,
  createCancellblePromise
};
/*! Bundled license information:

rete-engine/rete-engine.esm.js:
  (*!
  * rete-engine v2.0.0
  * (c) 2024 Vitaliy Stoliarov
  * Released under the MIT license.
  * *)
*/
//# sourceMappingURL=rete-engine.js.map
