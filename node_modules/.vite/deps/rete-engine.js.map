{
  "version": 3,
  "sources": ["../../@babel/runtime/helpers/esm/isNativeFunction.js", "../../@babel/runtime/helpers/esm/isNativeReflectConstruct.js", "../../@babel/runtime/helpers/esm/construct.js", "../../@babel/runtime/helpers/esm/wrapNativeSuper.js", "../../rete-engine/src/control-flow.ts", "../../rete-engine/src/control-flow-engine.ts", "../../rete-engine/src/dataflow.ts", "../../rete-engine/src/utils/cache.ts", "../../rete-engine/src/utils/cancellable.ts", "../../rete-engine/src/dataflow-engine.ts"],
  "sourcesContent": ["export default function _isNativeFunction(fn) {\r\n  try {\r\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\r\n  } catch (e) {\r\n    return typeof fn === \"function\";\r\n  }\r\n}", "export default function _isNativeReflectConstruct() {\r\n  try {\r\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n  } catch (t) {}\r\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\r\n    return !!t;\r\n  })();\r\n}", "import setPrototypeOf from \"./setPrototypeOf.js\";\r\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\r\nexport default function _construct(t, e, r) {\r\n  if (isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\r\n  var o = [null];\r\n  o.push.apply(o, e);\r\n  var p = new (t.bind.apply(t, o))();\r\n  return r && setPrototypeOf(p, r.prototype), p;\r\n}", "import getPrototypeOf from \"./getPrototypeOf.js\";\r\nimport setPrototypeOf from \"./setPrototypeOf.js\";\r\nimport isNativeFunction from \"./isNativeFunction.js\";\r\nimport construct from \"./construct.js\";\r\nexport default function _wrapNativeSuper(Class) {\r\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\r\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\r\n    if (Class === null || !isNativeFunction(Class)) return Class;\r\n    if (typeof Class !== \"function\") {\r\n      throw new TypeError(\"Super expression must either be null or a function\");\r\n    }\r\n    if (typeof _cache !== \"undefined\") {\r\n      if (_cache.has(Class)) return _cache.get(Class);\r\n      _cache.set(Class, Wrapper);\r\n    }\r\n    function Wrapper() {\r\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\r\n    }\r\n    Wrapper.prototype = Object.create(Class.prototype, {\r\n      constructor: {\r\n        value: Wrapper,\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n    return setPrototypeOf(Wrapper, Class);\r\n  };\r\n  return _wrapNativeSuper(Class);\r\n}", "import { NodeEditor, NodeId } from 'rete'\n\nimport { ClassicScheme } from './types'\n\n/**\n * ControlFlowNodeSetup is a set of functions that define how to execute a node.\n */\nexport type ControlFlowNodeSetup<T extends ClassicScheme['Node'], I extends (keyof T['inputs'])[] = string[], O extends (keyof T['outputs'])[] = string[]> = {\n  /** Specifies the inputs which are part of the control flow */\n  inputs: () => I\n  /** Specifies the outputs which are part of the control flow */\n  outputs: () => O\n  /** Called when the node received control from the previous node */\n  execute(input: I[number], forward: (output: O[number]) => any): any\n}\n\n/**\n * ControlFlow is a class that allows to execute nodes in a graph using Control flow approach.\n * @priority 7\n */\nexport class ControlFlow<Schemes extends ClassicScheme> {\n  setups = new Map<NodeId, ControlFlowNodeSetup<any, any, any>>()\n\n  /**\n   * @param editor NodeEditor instance\n   */\n  constructor(private editor: NodeEditor<Schemes>) { }\n\n  /**\n   * Adds the node to the control flow.\n   * @param node Node instance\n   * @param setup Set of functions that define how to execute the node\n   */\n  public add<T extends Schemes['Node']>(node: T, setup: ControlFlowNodeSetup<T, (keyof T['inputs'])[], (keyof T['outputs'])[]>) {\n    const affected = this.setups.get(node.id)\n\n    if (affected) {\n      throw new Error('already processed')\n    }\n    this.setups.set(node.id, setup)\n  }\n\n  /**\n   * Removes the node from the control flow.\n   * @param nodeId Node id\n   */\n  public remove(nodeId: NodeId) {\n    this.setups.delete(nodeId)\n  }\n\n  /**\n   * Execute the node and its successors (in case `forward` is called for some output).\n   * @param nodeId Node id\n   * @param input Input key that will be considered as the initiator of the execution\n   */\n  public execute(nodeId: NodeId, input?: string) {\n    const setup = this.setups.get(nodeId)\n\n    if (!setup) throw new Error('node is not initialized')\n    const inputKeys = setup.inputs()\n\n    if (input && !inputKeys.includes(input)) throw new Error('inputs don\\'t have a key')\n\n    setup.execute(input, (output) => {\n      const outputKeys = setup.outputs()\n\n      if (!outputKeys.includes(output)) throw new Error('outputs don\\'t have a key')\n\n      const cons = this.editor.getConnections().filter(c => {\n        return c.source === nodeId && c.sourceOutput === output\n      })\n\n      cons.forEach(con => {\n        this.execute(con.target, con.targetInput)\n      })\n    })\n  }\n}\n", "import { GetSchemes, NodeEditor, NodeId, Root, Scope } from 'rete'\n\nimport { ControlFlow } from './control-flow'\nimport { ClassicScheme } from './types'\n\nexport type ControlFlowEngineScheme = GetSchemes<\n  ClassicScheme['Node'] & { execute(input: string, forward: (output: string) => void): void },\n  ClassicScheme['Connection']\n>\n\ntype Configure<Schemes extends ControlFlowEngineScheme> = (node: Schemes['Node']) => ({\n  inputs: () => string[]\n  outputs: () => string[]\n})\n\n/**\n * ControlFlowEngine is a plugin that integrates ControlFlow with NodeEditor making it easy to use\n * @priority 9\n * @listens nodecreated\n * @listens noderemoved\n */\nexport class ControlFlowEngine<Schemes extends ControlFlowEngineScheme> extends Scope<never, [Root<Schemes>]> {\n  editor!: NodeEditor<Schemes>\n  controlflow!: ControlFlow<Schemes>\n\n  /**\n   * @param configure Allows to specify which inputs and outputs are part of the control flow\n   */\n  constructor(private configure?: Configure<Schemes>) {\n    super('control-flow-engine')\n\n    this.addPipe(context => {\n      if (context.type === 'nodecreated') {\n        this.add(context.data)\n      }\n      if (context.type === 'noderemoved') {\n        this.remove(context.data)\n      }\n      return context\n    })\n  }\n\n  setParent(scope: Scope<Root<Schemes>>): void {\n    super.setParent(scope)\n\n    this.editor = this.parentScope<NodeEditor<Schemes>>(NodeEditor)\n    this.controlflow = new ControlFlow(this.editor)\n  }\n\n  private add(node: Schemes['Node']) {\n    const options = this.configure\n      ? this.configure(node)\n      : { inputs: () => Object.keys(node.inputs), outputs: () => Object.keys(node.outputs) }\n\n    this.controlflow.add(node, {\n      inputs: options.inputs,\n      outputs: options.outputs,\n      execute: (input, forward) => {\n        node.execute(String(input), forward)\n      }\n    })\n  }\n\n  private remove(node: Schemes['Node']) {\n    this.controlflow.remove(node.id)\n  }\n\n  /**\n   * Trigger execution starting from the specified node.\n   * @param nodeId Node id\n   * @param input Input key that will be considered as the initiator of the execution\n   */\n  public execute(nodeId: NodeId, input?: string) {\n    this.controlflow.execute(nodeId, input)\n  }\n}\n", "import { NodeEditor, NodeId } from 'rete'\n\nimport { ClassicScheme } from './types'\n\n/**\n * DataflowNodeSetup is a set of functions that define how to process a node.\n */\nexport type DataflowNodeSetup<\n  T extends ClassicScheme['Node'],\n  I extends { [key in keyof T['inputs']]: any },\n  O extends { [key in keyof T['outputs']]: any }\n> = {\n  inputs: () => (keyof I)[]\n  outputs: () => (keyof O)[]\n  data(fetchInputs: () => Promise<{ [key in keyof I]: I[key][] }>): Promise<O> | O\n}\n\n/**\n * Dataflow is a class that allows to process nodes in a graph using Dataflow approach.\n * @priority 8\n */\nexport class Dataflow<Schemes extends ClassicScheme> {\n  setups = new Map<NodeId, DataflowNodeSetup<any, any, any>>()\n\n  /**\n   * @param editor NodeEditor instance\n   */\n  constructor(private editor: NodeEditor<Schemes>) { }\n\n  /**\n   * Adds the node to the dataflow.\n   * @param node Node instance\n   * @param setup Set of functions that define how to process the node\n   */\n  public add<T extends Schemes['Node']>(node: T, setup: DataflowNodeSetup<T, any, any>) {\n    const affected = this.setups.get(node.id)\n\n    if (affected) {\n      throw new Error('already processed')\n    }\n    this.setups.set(node.id, setup)\n  }\n\n  /**\n   * Removes the node from the dataflow.\n   * @param nodeId Node id\n   */\n  public remove(nodeId: NodeId) {\n    this.setups.delete(nodeId)\n  }\n\n  /**\n   * Fetches inputs of the node.\n   * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).\n   * @param nodeId Node id\n   * @returns Object with inputs\n   */\n  public async fetchInputs(nodeId: NodeId) {\n    const result = this.setups.get(nodeId)\n\n    if (!result) throw new Error('node is not initialized')\n\n    const inputKeys = result.inputs()\n\n    const cons = this.editor.getConnections().filter(c => {\n      return c.target === nodeId && inputKeys.includes(c.targetInput)\n    })\n\n    const inputs: Record<string, any> = {}\n    const consWithSourceData = await Promise.all(cons.map(async c => {\n      return {\n        c,\n        sourceData: await this.fetch(c.source)\n      }\n    }))\n\n    for (const { c, sourceData } of consWithSourceData) {\n      const previous = inputs[c.targetInput] ? inputs[c.targetInput] : []\n\n      inputs[c.targetInput] = [...previous, sourceData[c.sourceOutput]]\n    }\n\n    return inputs\n  }\n\n  /**\n   * Fetches outputs of the node.\n   * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.\n   * @param nodeId Node id\n   * @returns Object with outputs\n   */\n  public async fetch(nodeId: NodeId): Promise<Record<string, any>> {\n    const result = this.setups.get(nodeId)\n\n    if (!result) throw new Error('node is not initialized')\n\n    const outputKeys = result.outputs()\n    const data = await result.data(() => this.fetchInputs(nodeId))\n\n    const returningKeys = Object.keys(data) as (string | number | symbol)[]\n\n    if (!outputKeys.every(key => returningKeys.includes(key))) {\n      throw new Error(`dataflow node \"${nodeId}\" doesn't return all of required properties. Expected \"${outputKeys.join('\", \"')}\". Got \"${returningKeys.join('\", \"')}\"`)\n    }\n\n    return data\n  }\n}\n", "export class Cache<Key, T> {\n  cache = new Map<Key, T>()\n\n  constructor(private onDelete?: (item?: T) => void) {}\n\n  get(key: Key) {\n    return this.cache.get(key)\n  }\n\n  add(key: Key, data: T) {\n    if (this.cache.has(key)) throw new Error('cache already exists')\n\n    this.cache.set(key, data)\n  }\n\n  patch(key: Key, data: T) {\n    this.cache.set(key, data)\n  }\n\n  delete(key: Key) {\n    const item = this.cache.get(key)\n\n    this.cache.delete(key)\n    this.onDelete && this.onDelete(item)\n  }\n\n  clear() {\n    Array.from(this.cache.keys()).forEach(item => {\n      this.delete(item)\n    })\n  }\n}\n", "/**\n * Cancelled exception. Thrown when `reset` is called while fetching data.\n */\nexport class Cancelled extends Error {\n  constructor() {\n    super('cancelled')\n  }\n}\n\nexport type Cancellable<T> = Promise<T> & { cancel?: () => void }\ntype S<A, B> = (data: A) => B | PromiseLike<B>\n\nfunction createCancellblePromise<A, B>(...sequence: [S<void, A>, S<A, B>]): Cancellable<B>\nfunction createCancellblePromise<A, B, C>(...sequence: [S<void, A>, S<A, B>, S<B, C>]): Cancellable<C>\nfunction createCancellblePromise(...sequence: S<any, any>[]): Cancellable<any> {\n  let cancelled = false\n\n  function commit<R>(value: R): R {\n    if (cancelled) {\n      throw new Cancelled()\n    }\n    return value\n  }\n\n  // eslint-disable-next-line init-declarations\n  let reject: (reason?: any) => void\n\n  const promise: Cancellable<void> = new Promise<void>((res, rej) => {\n    reject = rej\n    res()\n  })\n\n  const n = (sequence as S<any, any>[]).reduce((p, item) => {\n    const t = p.then(item as any).then(commit)\n\n    return t\n  }, promise)\n\n  n.cancel = () => {\n    if (!cancelled) reject(new Cancelled())\n    cancelled = true\n  }\n\n  return n\n}\n\nexport {\n  createCancellblePromise\n}\n", "import { GetSchemes, NodeEditor, NodeId, Root, Scope } from 'rete'\n\nimport { Dataflow } from './dataflow'\nimport { ClassicScheme } from './types'\nimport { Cache } from './utils/cache'\nimport { Cancellable, createCancellblePromise } from './utils/cancellable'\n\nexport type DataflowNode = { data(inputs: Record<string, any>): Promise<Record<string, any>> | Record<string, any> }\nexport type DataflowEngineScheme = GetSchemes<\n  ClassicScheme['Node'] & DataflowNode,\n  ClassicScheme['Connection']\n>\n\ntype Configure<Schemes extends DataflowEngineScheme> = (node: Schemes['Node']) => ({\n  inputs: () => string[]\n  outputs: () => string[]\n})\n\n/**\n * DataflowEngine is a plugin that integrates Dataflow with NodeEditor making it easy to use.\n * Additionally, it provides a cache for the data of each node in order to avoid recurring calculations.\n * @priority 10\n * @listens nodecreated\n * @listens noderemoved\n */\nexport class DataflowEngine<Schemes extends DataflowEngineScheme> extends Scope<never, [Root<Schemes>]> {\n  editor!: NodeEditor<Schemes>\n  dataflow?: Dataflow<Schemes>\n  cache = new Cache<NodeId, Cancellable<Record<string, any>>>(data => data?.cancel && data.cancel())\n\n  constructor(private configure?: Configure<Schemes>) {\n    super('dataflow-engine')\n\n    this.addPipe(context => {\n      if (context.type === 'nodecreated') {\n        this.add(context.data)\n      }\n      if (context.type === 'noderemoved') {\n        this.remove(context.data)\n      }\n      return context\n    })\n  }\n\n  setParent(scope: Scope<Root<Schemes>>): void {\n    super.setParent(scope)\n\n    this.editor = this.parentScope<NodeEditor<Schemes>>(NodeEditor)\n    this.dataflow = new Dataflow(this.editor)\n  }\n\n  private getDataflow() {\n    if (!this.dataflow) throw new Error(`DataflowEngine isn't attached to NodeEditor`)\n    return this.dataflow\n  }\n\n  private add(node: Schemes['Node']) {\n    const options = this.configure\n      ? this.configure(node)\n      : { inputs: () => Object.keys(node.inputs), outputs: () => Object.keys(node.outputs) }\n\n    this.getDataflow().add(node, {\n      inputs: options.inputs,\n      outputs: options.outputs,\n      data: async (fetchInputs) => {\n        const cache = this.cache.get(node.id)\n\n        if (cache) return cache\n\n        const cancellable = createCancellblePromise(\n          () => fetchInputs(),\n          inputs => node.data(inputs)\n        )\n\n        this.cache.add(node.id, cancellable)\n\n        return cancellable\n      }\n    })\n  }\n\n  private remove(node: Schemes['Node']) {\n    this.getDataflow().remove(node.id)\n  }\n\n  /**\n   * Resets the cache of the node and all its predecessors.\n   * @param nodeId Node id to reset. If not specified, all nodes will be reset.\n   */\n  public reset(nodeId?: NodeId) {\n    if (nodeId) {\n      const setup = this.getDataflow().setups.get(nodeId)\n\n      if (!setup) throw 'setup'\n\n      const outputKeys = setup.outputs()\n\n      this.cache.delete(nodeId)\n      this.editor.getConnections()\n        .filter(c => c.source === nodeId && outputKeys.includes(c.sourceOutput))\n        .forEach(c => this.reset(c.target))\n    } else {\n      this.cache.clear()\n    }\n  }\n\n  /**\n   * Fetches input data for the node by fetching data for all its predecessors recursively.\n   * @param nodeId Node id to fetch input data for\n   * @throws `Cancelled when `reset` is called while fetching data\n   */\n  public async fetchInputs(nodeId: NodeId) {\n    return this.getDataflow().fetchInputs(nodeId)\n  }\n\n  /**\n   * Fetches output data of the node\n   * @param nodeId Node id to fetch data from\n   * @throws `Cancelled` when `reset` is called while fetching data\n   */\n  public async fetch(nodeId: NodeId) {\n    return this.getDataflow().fetch(nodeId)\n  }\n}\n"],
  "mappings": "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",
  "names": ["t", "_isNativeReflectConstruct", "_wrapNativeSuper", "Class", "ControlFlow", "editor", "_classCallCheck", "_defineProperty", "Map", "_createClass", "key", "value", "add", "node", "setup", "affected", "setups", "get", "id", "Error", "set", "remove", "nodeId", "execute", "input", "_this", "inputKeys", "inputs", "includes", "output", "outputKeys", "outputs", "cons", "getConnections", "filter", "c", "source", "sourceOutput", "forEach", "con", "target", "targetInput", "ControlFlowEngine", "_Scope", "_inherits", "_super", "_createSuper", "configure", "call", "addPipe", "context", "type", "data", "setParent", "scope", "_get", "_getPrototypeOf", "prototype", "parentScope", "NodeEditor", "controlflow", "options", "Object", "keys", "forward", "String", "Scope", "Dataflow", "_fetchInputs", "_asyncToGenerator", "_regeneratorRuntime", "mark", "_callee2", "result", "consWithSourceData", "_iterator", "_step", "_step$value", "sourceData", "previous", "wrap", "_callee2$", "_context2", "prev", "next", "Promise", "all", "map", "_ref", "_callee", "_callee$", "_context", "t0", "fetch", "t1", "sent", "abrupt", "stop", "_x2", "apply", "arguments", "_createForOfIteratorHelper", "s", "n", "done", "concat", "_toConsumableArray", "err", "e", "f", "fetchInputs", "_x", "_fetch", "_callee3", "_this2", "returningKeys", "_callee3$", "_context3", "every", "join", "_x3", "Cache", "onDelete", "cache", "has", "patch", "_delete", "item", "clear", "Array", "from", "Cancelled", "_Error", "_wrapNativeSuper", "createCancellblePromise", "cancelled", "commit", "reject", "promise", "res", "rej", "_len", "length", "sequence", "_key", "reduce", "p", "t", "then", "cancel", "DataflowEngine", "_assertThisInitialized", "dataflow", "getDataflow", "_data", "cancellable", "reset", "_this3"]
}
