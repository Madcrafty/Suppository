{
  "version": 3,
  "sources": ["../../rete-area-3d-plugin/node_modules/three/examples/jsm/renderers/CSS3DRenderer.js", "../../rete-area-3d-plugin/src/utils/geometry.ts", "../../rete-area-3d-plugin/src/scene/ObjectHTML.ts", "../../rete-area-3d-plugin/src/content.ts", "../../rete-area-3d-plugin/src/scene/Drag/DragControls.ts", "../../rete-area-3d-plugin/src/scene/Drag/DraggableObject3D.ts", "../../rete-area-3d-plugin/src/scene/Drag/index.ts", "../../rete-area-3d-plugin/src/scene/HybridRenderer.ts", "../../rete-area-3d-plugin/node_modules/three/examples/jsm/controls/OrbitControls.js", "../../rete-area-3d-plugin/src/scene/OrbitControls/index.ts", "../../rete-area-3d-plugin/src/scene/index.ts", "../../rete-area-3d-plugin/src/area.ts", "../../rete-area-3d-plugin/src/connection-view.ts", "../../rete-area-3d-plugin/src/elements-holder.ts", "../../rete-area-3d-plugin/src/node-view.ts", "../../rete-area-3d-plugin/src/extensions/animate.ts", "../../rete-area-3d-plugin/src/utils/shapes.ts", "../../rete-area-3d-plugin/src/extensions/forms/comment.ts", "../../rete-area-3d-plugin/node_modules/parse-svg-path/index.js", "../../rete-area-3d-plugin/node_modules/adaptive-bezier-curve/function.js", "../../rete-area-3d-plugin/node_modules/adaptive-bezier-curve/index.js", "../../rete-area-3d-plugin/node_modules/abs-svg-path/index.js", "../../rete-area-3d-plugin/node_modules/normalize-svg-path/index.js", "../../rete-area-3d-plugin/node_modules/vec2-copy/index.js", "../../rete-area-3d-plugin/node_modules/svg-path-contours/index.js", "../../rete-area-3d-plugin/src/extensions/forms/connection/geometry.ts", "../../rete-area-3d-plugin/src/extensions/forms/connection/index.ts", "../../rete-area-3d-plugin/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js", "../../rete-area-3d-plugin/src/extensions/forms/node/geometry.ts", "../../rete-area-3d-plugin/src/extensions/forms/node/index.ts", "../../rete-area-3d-plugin/src/extensions/forms/reroute.ts", "../../rete-area-3d-plugin/src/extensions/forms/index.ts", "../../rete-area-3d-plugin/src/utils/bounding-box.ts", "../../rete-area-3d-plugin/src/utils/rects.ts", "../../rete-area-3d-plugin/src/extensions/bounding-box.ts", "../../rete-area-3d-plugin/src/extensions/lookAt.ts", "../../rete-area-3d-plugin/src/extensions/index.ts", "../../rete-area-3d-plugin/src/index.ts"],
  "sourcesContent": ["import {\n\tMatrix4,\n\tObject3D,\n\tQuaternion,\n\tVector3\n} from 'three';\n\n/**\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\n */\n\nconst _position = new Vector3();\nconst _quaternion = new Quaternion();\nconst _scale = new Vector3();\n\nclass CSS3DObject extends Object3D {\n\n\tconstructor( element = document.createElement( 'div' ) ) {\n\n\t\tsuper();\n\n\t\tthis.isCSS3DObject = true;\n\n\t\tthis.element = element;\n\t\tthis.element.style.position = 'absolute';\n\t\tthis.element.style.pointerEvents = 'auto';\n\t\tthis.element.style.userSelect = 'none';\n\n\t\tthis.element.setAttribute( 'draggable', false );\n\n\t\tthis.addEventListener( 'removed', function () {\n\n\t\t\tthis.traverse( function ( object ) {\n\n\t\t\t\tif ( object.element instanceof Element && object.element.parentNode !== null ) {\n\n\t\t\t\t\tobject.element.parentNode.removeChild( object.element );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.element = source.element.cloneNode( true );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CSS3DSprite extends CSS3DObject {\n\n\tconstructor( element ) {\n\n\t\tsuper( element );\n\n\t\tthis.isCSS3DSprite = true;\n\n\t\tthis.rotation2D = 0;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.rotation2D = source.rotation2D;\n\n\t\treturn this;\n\n\t}\n\n}\n\n//\n\nconst _matrix = new Matrix4();\nconst _matrix2 = new Matrix4();\n\nclass CSS3DRenderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tconst _this = this;\n\n\t\tlet _width, _height;\n\t\tlet _widthHalf, _heightHalf;\n\n\t\tconst cache = {\n\t\t\tcamera: { fov: 0, style: '' },\n\t\t\tobjects: new WeakMap()\n\t\t};\n\n\t\tconst domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );\n\n\t\tdomElement.style.overflow = 'hidden';\n\n\t\tthis.domElement = domElement;\n\n\t\tconst viewElement = document.createElement( 'div' );\n\t\tviewElement.style.transformOrigin = '0 0';\n\t\tviewElement.style.pointerEvents = 'none';\n\t\tdomElement.appendChild( viewElement );\n\n\t\tconst cameraElement = document.createElement( 'div' );\n\n\t\tcameraElement.style.transformStyle = 'preserve-3d';\n\n\t\tviewElement.appendChild( cameraElement );\n\n\t\tthis.getSize = function () {\n\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\n\t\t};\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tconst fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;\n\n\t\t\tif ( cache.camera.fov !== fov ) {\n\n\t\t\t\tviewElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : '';\n\t\t\t\tcache.camera.fov = fov;\n\n\t\t\t}\n\n\t\t\tif ( camera.view && camera.view.enabled ) {\n\n\t\t\t\t// view offset\n\t\t\t\tviewElement.style.transform = `translate( ${ - camera.view.offsetX * ( _width / camera.view.width ) }px, ${ - camera.view.offsetY * ( _height / camera.view.height ) }px )`;\n\n\t\t\t\t// view fullWidth and fullHeight, view width and height\n\t\t\t\tviewElement.style.transform += `scale( ${ camera.view.fullWidth / camera.view.width }, ${ camera.view.fullHeight / camera.view.height } )`;\n\n\t\t\t} else {\n\n\t\t\t\tviewElement.style.transform = '';\n\n\t\t\t}\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tlet tx, ty;\n\n\t\t\tif ( camera.isOrthographicCamera ) {\n\n\t\t\t\ttx = - ( camera.right + camera.left ) / 2;\n\t\t\t\tty = ( camera.top + camera.bottom ) / 2;\n\n\t\t\t}\n\n\t\t\tconst scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;\n\t\t\tconst cameraCSSMatrix = camera.isOrthographicCamera ?\n\t\t\t\t`scale( ${ scaleByViewOffset } )` + 'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :\n\t\t\t\t`scale( ${ scaleByViewOffset } )` + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );\n\n\t\t\tconst style = cameraCSSMatrix +\n\t\t\t\t'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';\n\n\t\t\tif ( cache.camera.style !== style ) {\n\n\t\t\t\tcameraElement.style.transform = style;\n\n\t\t\t\tcache.camera.style = style;\n\n\t\t\t}\n\n\t\t\trenderObject( scene, scene, camera, cameraCSSMatrix );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_widthHalf = _width / 2;\n\t\t\t_heightHalf = _height / 2;\n\n\t\t\tdomElement.style.width = width + 'px';\n\t\t\tdomElement.style.height = height + 'px';\n\n\t\t\tviewElement.style.width = width + 'px';\n\t\t\tviewElement.style.height = height + 'px';\n\n\t\t\tcameraElement.style.width = width + 'px';\n\t\t\tcameraElement.style.height = height + 'px';\n\n\t\t};\n\n\t\tfunction epsilon( value ) {\n\n\t\t\treturn Math.abs( value ) < 1e-10 ? 0 : value;\n\n\t\t}\n\n\t\tfunction getCameraCSSMatrix( matrix ) {\n\n\t\t\tconst elements = matrix.elements;\n\n\t\t\treturn 'matrix3d(' +\n\t\t\t\tepsilon( elements[ 0 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 1 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 2 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 3 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 4 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 5 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 6 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 7 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 8 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 9 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 10 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 11 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 12 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 13 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 14 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 15 ] ) +\n\t\t\t')';\n\n\t\t}\n\n\t\tfunction getObjectCSSMatrix( matrix ) {\n\n\t\t\tconst elements = matrix.elements;\n\t\t\tconst matrix3d = 'matrix3d(' +\n\t\t\t\tepsilon( elements[ 0 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 1 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 2 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 3 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 4 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 5 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 6 ] ) + ',' +\n\t\t\t\tepsilon( - elements[ 7 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 8 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 9 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 10 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 11 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 12 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 13 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 14 ] ) + ',' +\n\t\t\t\tepsilon( elements[ 15 ] ) +\n\t\t\t')';\n\n\t\t\treturn 'translate(-50%,-50%)' + matrix3d;\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, cameraCSSMatrix ) {\n\n\t\t\tif ( object.isCSS3DObject ) {\n\n\t\t\t\tconst visible = ( object.visible === true ) && ( object.layers.test( camera.layers ) === true );\n\t\t\t\tobject.element.style.display = ( visible === true ) ? '' : 'none';\n\n\t\t\t\tif ( visible === true ) {\n\n\t\t\t\t\tobject.onBeforeRender( _this, scene, camera );\n\n\t\t\t\t\tlet style;\n\n\t\t\t\t\tif ( object.isCSS3DSprite ) {\n\n\t\t\t\t\t\t// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\n\n\t\t\t\t\t\t_matrix.copy( camera.matrixWorldInverse );\n\t\t\t\t\t\t_matrix.transpose();\n\n\t\t\t\t\t\tif ( object.rotation2D !== 0 ) _matrix.multiply( _matrix2.makeRotationZ( object.rotation2D ) );\n\n\t\t\t\t\t\tobject.matrixWorld.decompose( _position, _quaternion, _scale );\n\t\t\t\t\t\t_matrix.setPosition( _position );\n\t\t\t\t\t\t_matrix.scale( _scale );\n\n\t\t\t\t\t\t_matrix.elements[ 3 ] = 0;\n\t\t\t\t\t\t_matrix.elements[ 7 ] = 0;\n\t\t\t\t\t\t_matrix.elements[ 11 ] = 0;\n\t\t\t\t\t\t_matrix.elements[ 15 ] = 1;\n\n\t\t\t\t\t\tstyle = getObjectCSSMatrix( _matrix );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstyle = getObjectCSSMatrix( object.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst element = object.element;\n\t\t\t\t\tconst cachedObject = cache.objects.get( object );\n\n\t\t\t\t\tif ( cachedObject === undefined || cachedObject.style !== style ) {\n\n\t\t\t\t\t\telement.style.transform = style;\n\n\t\t\t\t\t\tconst objectData = { style: style };\n\t\t\t\t\t\tcache.objects.set( object, objectData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( element.parentNode !== cameraElement ) {\n\n\t\t\t\t\t\tcameraElement.appendChild( element );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.onAfterRender( _this, scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\trenderObject( object.children[ i ], scene, camera, cameraCSSMatrix );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { CSS3DObject, CSS3DSprite, CSS3DRenderer };\n", "import { BufferGeometry } from 'three'\n\nexport function flipFaces(geometry: BufferGeometry) {\n  const index = geometry.getIndex()\n\n  if (index) {\n    const numTriangles = index.count / 3\n\n    for (let i = 0; i < numTriangles; i++) {\n      const a = index.getX(i * 3 + 2)\n      const b = index.getX(i * 3 + 1)\n      const c = index.getX(i * 3)\n\n      index.setXYZ(i * 3, a, b, c)\n    }\n  }\n}\n", "import {\n  BackSide, BufferGeometry, FrontSide, Material,\n  Mesh, MeshBasicMaterial, NoBlending, Object3D, ShadowMaterial\n} from 'three'\nimport { CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer.js'\n\nimport { flipFaces } from '../utils/geometry'\n\nexport function createMaterial(transparent: boolean) {\n  return new ShadowMaterial({\n    transparent: true,\n    opacity: transparent ? 0.5 : 0.7,\n    blending: NoBlending,\n    side: FrontSide\n  })\n}\n\nexport function createBackMaterial() {\n  return new MeshBasicMaterial({\n    color: 0x6e88ff,\n    side: BackSide\n  })\n}\n\nexport type ObjectHTMLMaterials = {\n  front?: Material\n  back?: Material\n}\n\nexport class ObjectHTML extends Object3D {\n  css3dObject: CSS3DObject\n  front: Mesh\n  back: Mesh\n\n  constructor(element: HTMLElement) {\n    super()\n    this.css3dObject = new CSS3DObject(element)\n    this.css3dObject.onAfterRender = () => {\n      const internalTranslate = ' translate(50%, 50%)'\n\n      if (!element.style.transform.endsWith(internalTranslate)) {\n        element.style.transform += internalTranslate\n      }\n    }\n    this.add(this.css3dObject)\n\n    const front = new Mesh()\n\n    this.front = front\n    this.add(front)\n\n    const back = new Mesh()\n\n    back.castShadow = true\n    this.back = back\n    this.add(back)\n\n    this.updateMaterials()\n  }\n\n  updateGeometry(geometry?: BufferGeometry) {\n    const scaled = geometry?.clone().scale(1, -1, 1)\n\n    if (scaled) flipFaces(scaled)\n\n    if (this.front) this.front.geometry = scaled || new BufferGeometry()\n    if (this.back) this.back.geometry = scaled || new BufferGeometry()\n  }\n\n  updateMaterials(materials?: ObjectHTMLMaterials) {\n    if (this.front) this.front.material = materials?.front || createMaterial(false)\n    if (this.back) this.back.material = materials?.back || createBackMaterial()\n  }\n}\n\nexport function findTop(objects: ObjectHTML[]) {\n  objects.sort((a, b) => {\n    if (!a.css3dObject || !b.css3dObject) return 0\n    const position = a.css3dObject.element.compareDocumentPosition(b.css3dObject.element)\n\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    return 0\n  })\n\n  return objects[0]\n}\n", "import { BufferGeometry } from 'three'\n\nimport { HybridScene } from './scene'\nimport { ObjectHTML, ObjectHTMLMaterials } from './scene/ObjectHTML'\n\n/**\n * Responsible for managing 2D content in the plane of 3D scene for a current editor\n */\nexport class Content<Scope> {\n  public holder: HTMLElement\n  public objects = new WeakMap<HTMLElement, ObjectHTML>()\n\n  constructor(private scene: HybridScene<Scope>, private scope: Scope, private reordered: (target: HTMLElement) => Promise<unknown>) {\n    const css3dContainer = scene.renderer.css3d.domElement.firstElementChild?.firstElementChild\n\n    if (!css3dContainer || !(css3dContainer instanceof HTMLElement)) {\n      throw new Error('cannot find container for css3d element')\n    }\n\n    this.holder = css3dContainer\n  }\n\n  public getPointerFrom(event: MouseEvent) {\n    const { left, top } = this.holder.getBoundingClientRect()\n    const x = event.clientX - left\n    const y = event.clientY - top\n\n    return { x, y }\n  }\n\n  /**\n   * Add an HTML element to the 3D scene\n   * @param element HTML element\n   */\n  add(element: HTMLElement, object = new ObjectHTML(element)) {\n    this.objects.set(element, object)\n    this.holder.appendChild(element)\n    this.scene.add(object, this.scope)\n  }\n\n  /**\n   * Reorder the given element in the 3D scene\n   * @param target HTML element to reorder\n   * @param next HTML element to insert before\n   * @throws if `target` or `next` are not in the scene\n   */\n  // eslint-disable-next-line no-undef\n  async reorder(target: HTMLElement, next: ChildNode | null) {\n    if (!this.holder.contains(target)) {\n      throw new Error(`content doesn't have 'target' for reordering`)\n    }\n    if (next !== null && !this.holder.contains(next)) {\n      throw new Error(`content doesn't have 'next' for reordering`)\n    }\n\n    this.holder.insertBefore(target, next)\n    await this.reordered(target)\n  }\n\n  /**\n   * Remove an HTML element from the 3D scene\n   * @param element HTML element\n   */\n  remove(element: HTMLElement) {\n    const object = this.objects.get(element)\n\n    if (object) {\n      this.objects.delete(element)\n      this.scene.remove(object, this.scope)\n    }\n  }\n\n  /**\n   * Update the form (geometry) of the given element\n   */\n  updateGeometry(element: HTMLElement, geometry?: BufferGeometry | ((old?: BufferGeometry) => BufferGeometry | undefined)) {\n    const object = this.objects.get(element)\n\n    if (object) {\n      object.updateGeometry(typeof geometry === 'function' ? geometry(object.front.geometry) : geometry)\n    }\n  }\n\n  /**\n   * Update the material of the given element\n   */\n  updateMaterials(element: HTMLElement, materials?: ObjectHTMLMaterials) {\n    const object = this.objects.get(element)\n\n    if (object) object.updateMaterials(materials)\n  }\n}\n", "import {\n  Camera, EventDispatcher, Intersection, Matrix4,\n  Object3D, Plane, Raycaster, Vector2, Vector3\n} from 'three'\n\nimport { findTop, ObjectHTML } from '../ObjectHTML'\n\ntype DefaultObject3D = Object3D\nexport type DragStartEvent = { type: 'dragstart', object: DefaultObject3D }\nexport type DragEvent = { type: 'drag', object: DefaultObject3D, position: Vector3 }\nexport type DragEndEvent = { type: 'dragend', object: DefaultObject3D }\n\nconst raycaster = new Raycaster()\n\n// EventDispatcher should have default generic for three 152-156 compatibility\nclass DragControls extends EventDispatcher {\n  enabled = true\n  intersections: Intersection<ObjectHTML>[] = []\n  selected: Object3D | null = null\n  hovered: Object3D | null = null\n  objects = new Set<DefaultObject3D>()\n\n  private pointer = new Vector2()\n  private offset = new Vector3()\n  private intersection = new Vector3()\n  private worldPosition = new Vector3()\n  private inverseMatrix = new Matrix4()\n\n  constructor(private camera: Camera, private domElement: HTMLElement, private getPlane: (object: Object3D) => Plane) {\n    super()\n\n    this.domElement.style.touchAction = 'none' // disable touch scroll\n    this.activate()\n  }\n\n  attach(object: Object3D) {\n    this.objects.add(object)\n  }\n\n  detach(object: Object3D) {\n    this.objects.delete(object)\n  }\n\n  activate() {\n    this.domElement.addEventListener('pointermove', this.onPointerMove)\n    this.domElement.addEventListener('pointerdown', this.onPointerDown)\n    this.domElement.addEventListener('pointerup', this.onPointerCancel)\n    this.domElement.addEventListener('pointerleave', this.onPointerCancel)\n  }\n\n  deactivate() {\n    this.domElement.removeEventListener('pointermove', this.onPointerMove)\n    this.domElement.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement.removeEventListener('pointerup', this.onPointerCancel)\n    this.domElement.removeEventListener('pointerleave', this.onPointerCancel)\n\n    this.domElement.style.cursor = ''\n  }\n\n  dispose() {\n    this.deactivate()\n  }\n\n  getObjects(): Object3D[] {\n    return Array.from(this.objects.values())\n  }\n\n  getRaycaster() {\n    return raycaster\n  }\n\n  onPointerMove = (event: PointerEvent) => {\n    if (this.enabled === false) return\n\n    this.updatePointer(event)\n\n    raycaster.setFromCamera(this.pointer, this.camera)\n\n    if (this.selected) {\n      if (raycaster.ray.intersectPlane(this.getPlane(this.selected), this.intersection)) {\n        const newPosition = this.intersection.sub(this.offset).applyMatrix4(this.inverseMatrix)\n\n        const eventData: DragEvent = { type: 'drag', object: this.selected, position: newPosition }\n\n        this.dispatchEvent(eventData as never)\n      }\n    }\n  }\n\n  findContainer(intersection: Intersection<ObjectHTML>) {\n    let object: ObjectHTML | null = null\n    const objects = this.getObjects()\n\n    intersection.object.traverseAncestors(intersectedObject => {\n      if (objects.includes(intersectedObject) && intersectedObject instanceof ObjectHTML) object = intersectedObject\n    })\n    if (!object) throw new Error('cannot find Object3D')\n\n    return object\n  }\n\n  findIntersectedObject(intersections: Intersection<ObjectHTML>[]) {\n    return findTop(intersections.map(i => this.findContainer(i)))\n  }\n\n  onPointerDown = (event: MouseEvent) => {\n    if (this.enabled === false) return\n\n    this.updatePointer(event)\n\n    this.intersections.length = 0\n\n    raycaster.setFromCamera(this.pointer, this.camera)\n    this.intersections = raycaster.intersectObjects(this.getObjects(), true)\n\n    if (this.intersections.length > 0) {\n      this.selected = this.findIntersectedObject(this.intersections) || null\n\n      if (!this.selected) return\n      if (!this.selected.parent) throw new Error('parent required for selected object')\n\n      if (raycaster.ray.intersectPlane(this.getPlane(this.selected), this.intersection)) {\n        this.inverseMatrix.copy(this.selected.parent.matrixWorld).invert()\n        this.offset.copy(this.intersection).sub(this.worldPosition.setFromMatrixPosition(this.selected.matrixWorld))\n      }\n\n      event.stopPropagation()\n      this.domElement.style.cursor = 'move'\n\n      const eventData: DragStartEvent = { type: 'dragstart', object: this.selected }\n\n      this.dispatchEvent(eventData as never)\n    }\n  }\n\n  onPointerCancel = () => {\n    if (this.enabled === false) return\n\n    if (this.selected) {\n      const eventData: DragEndEvent = { type: 'dragend', object: this.selected }\n\n      this.dispatchEvent(eventData as never)\n\n      this.selected = null\n    }\n\n    this.domElement.style.cursor = this.hovered ? 'pointer' : 'auto'\n  }\n\n  updatePointer = (event: MouseEvent) => {\n    const rect = this.domElement.getBoundingClientRect()\n\n    this.pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1\n    this.pointer.y = - (event.clientY - rect.top) / rect.height * 2 + 1\n  }\n}\n\nexport { DragControls }\n", "import { ObjectHTML } from '../ObjectHTML'\n\nexport class DraggableObject3D extends ObjectHTML {\n  constructor(element: HTMLElement, public events: {\n    start: () => void,\n    translate: (x: number, y: number, z: number) => void,\n    drag: () => void\n  }) {\n    super(element)\n  }\n}\n", "import { DragControls, DragStartEvent, DragEvent, DragEndEvent } from './DragControls'\nimport { DraggableObject3D } from './DraggableObject3D'\n\nexport { DragControls, DraggableObject3D }\n\nexport function attachDraggableHooks(controls: DragControls) {\n  controls.addEventListener('dragstart', (e: any) => {\n    const event = e as DragStartEvent\n\n    if (event.object instanceof DraggableObject3D) {\n      event.object.events.start()\n    }\n  })\n  controls.addEventListener('drag', (e: any) => {\n    const event = e as DragEvent\n\n    if (event.object instanceof DraggableObject3D) {\n      const { x, y, z } = event.position\n\n      event.object.events.translate(x, y, z)\n    }\n  })\n  controls.addEventListener('dragend', (e: any) => {\n    const event = e as DragEndEvent\n\n    if (event.object instanceof DraggableObject3D) {\n      event.object.events.drag()\n    }\n  })\n}\n", "import { Camera, PCFSoftShadowMap, Scene, WebGLRenderer } from 'three'\nimport { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer.js'\n\n/**\n * HybridRenderer is a wrapper for Three.js CSS3DRenderer and WebGLRenderer.\n */\nexport class HybridRenderer {\n  /** CSS3DRenderer instance created by default */\n  css3d: CSS3DRenderer\n  /** WebGLRenderer instance created by default */\n  webgl: WebGLRenderer\n  domElement: HTMLElement\n\n  constructor() {\n    this.css3d = this.getDefaultCSS3DRenderer()\n    this.webgl = this.getDefaultWebGLRenderer()\n\n    this.domElement = document.createElement('div')\n\n    this.css3d.domElement.setAttribute('data-css3d', 'true')\n\n    fillAbsolute(this.domElement)\n    fillAbsolute(this.css3d.domElement)\n    fillAbsolute(this.webgl.domElement)\n\n    this.domElement.appendChild(this.css3d.domElement)\n    this.domElement.appendChild(this.webgl.domElement)\n\n    this.webgl.domElement.style.pointerEvents = 'none'\n  }\n\n  getContent() {\n    return this.webgl.domElement.firstElementChild\n  }\n\n  private getDefaultCSS3DRenderer() {\n    const css3d = new CSS3DRenderer()\n\n    return css3d\n  }\n\n  private getDefaultWebGLRenderer() {\n    const webgl = new WebGLRenderer({ alpha: false, antialias: true })\n\n    webgl.setPixelRatio(window.devicePixelRatio)\n    webgl.setClearColor(0xffffff, 0)\n    webgl.shadowMap.enabled = true\n    webgl.shadowMap.type = PCFSoftShadowMap\n\n    return webgl\n  }\n\n  setSize(width: number, height: number) {\n    this.css3d.setSize(width, height)\n    this.webgl.setSize(width, height)\n  }\n\n  render(scene: Scene, camera: Camera) {\n    this.css3d.render(scene, camera)\n    this.webgl.render(scene, camera)\n  }\n}\n\nfunction fillAbsolute(el: HTMLElement) {\n  el.style.width = '100%'\n  el.style.height = '100%'\n  el.style.position = 'absolute'\n  el.style.left = '0'\n  el.style.top = '0'\n}\n", "import {\n\tEventDispatcher,\n\tMOUSE,\n\tQuaternion,\n\tSpherical,\n\tTOUCH,\n\tVector2,\n\tVector3,\n\tPlane,\n\tRay,\n\tMathUtils\n} from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );\n\nclass OrbitControls extends EventDispatcher {\n\n\tconstructor( object, domElement ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.05;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.panSpeed = 1.0;\n\t\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\tthis.zoomToCursor = false;\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n\n\t\t// Touch fingers\n\t\tthis.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// the target DOM element for key events\n\t\tthis._domElementKeyEvents = null;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.getDistance = function () {\n\n\t\t\treturn this.object.position.distanceTo( this.target );\n\n\t\t};\n\n\t\tthis.listenToKeyEvents = function ( domElement ) {\n\n\t\t\tdomElement.addEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = domElement;\n\n\t\t};\n\n\t\tthis.stopListenToKeyEvents = function () {\n\n\t\t\tthis._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\tthis._domElementKeyEvents = null;\n\n\t\t};\n\n\t\tthis.saveState = function () {\n\n\t\t\tscope.target0.copy( scope.target );\n\t\t\tscope.position0.copy( scope.object.position );\n\t\t\tscope.zoom0 = scope.object.zoom;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tconst quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );\n\t\t\tconst quatInverse = quat.clone().invert();\n\n\t\t\tconst lastPosition = new Vector3();\n\t\t\tconst lastQuaternion = new Quaternion();\n\t\t\tconst lastTargetPosition = new Vector3();\n\n\t\t\tconst twoPI = 2 * Math.PI;\n\n\t\t\treturn function update( deltaTime = null ) {\n\n\t\t\t\tconst position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle( deltaTime ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( scope.enableDamping ) {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t}\n\n\t\t\t\t// restrict theta to be between desired limits\n\n\t\t\t\tlet min = scope.minAzimuthAngle;\n\t\t\t\tlet max = scope.maxAzimuthAngle;\n\n\t\t\t\tif ( isFinite( min ) && isFinite( max ) ) {\n\n\t\t\t\t\tif ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;\n\n\t\t\t\t\tif ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;\n\n\t\t\t\t\tif ( min <= max ) {\n\n\t\t\t\t\t\tspherical.theta = Math.max( min, Math.min( max, spherical.theta ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tspherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?\n\t\t\t\t\t\t\tMath.max( min, spherical.theta ) :\n\t\t\t\t\t\t\tMath.min( max, spherical.theta );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\t// move target to panned location\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tscope.target.addScaledVector( panOffset, scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\t}\n\n\t\t\t\t// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n\t\t\t\t// we adjust zoom later in these cases\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tspherical.radius = clampDistance( spherical.radius * scale );\n\n\t\t\t\t}\n\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t\tpanOffset.multiplyScalar( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t// adjust camera position\n\t\t\t\tlet zoomChanged = false;\n\t\t\t\tif ( scope.zoomToCursor && performCursorZoom ) {\n\n\t\t\t\t\tlet newRadius = null;\n\t\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t\t// move the camera down the pointer ray\n\t\t\t\t\t\t// this method avoids floating point error\n\t\t\t\t\t\tconst prevRadius = offset.length();\n\t\t\t\t\t\tnewRadius = clampDistance( prevRadius * scale );\n\n\t\t\t\t\t\tconst radiusDelta = prevRadius - newRadius;\n\t\t\t\t\t\tscope.object.position.addScaledVector( dollyDirection, radiusDelta );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t\t// adjust the ortho camera position based on zoom changes\n\t\t\t\t\t\tconst mouseBefore = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseBefore.unproject( scope.object );\n\n\t\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\t\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t\t\tconst mouseAfter = new Vector3( mouse.x, mouse.y, 0 );\n\t\t\t\t\t\tmouseAfter.unproject( scope.object );\n\n\t\t\t\t\t\tscope.object.position.sub( mouseAfter ).add( mouseBefore );\n\t\t\t\t\t\tscope.object.updateMatrixWorld();\n\n\t\t\t\t\t\tnewRadius = offset.length();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );\n\t\t\t\t\t\tscope.zoomToCursor = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle the placement of the target\n\t\t\t\t\tif ( newRadius !== null ) {\n\n\t\t\t\t\t\tif ( this.screenSpacePanning ) {\n\n\t\t\t\t\t\t\t// position the orbit target in front of the new camera position\n\t\t\t\t\t\t\tscope.target.set( 0, 0, - 1 )\n\t\t\t\t\t\t\t\t.transformDirection( scope.object.matrix )\n\t\t\t\t\t\t\t\t.multiplyScalar( newRadius )\n\t\t\t\t\t\t\t\t.add( scope.object.position );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// get the ray and translation plane to compute target\n\t\t\t\t\t\t\t_ray.origin.copy( scope.object.position );\n\t\t\t\t\t\t\t_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );\n\n\t\t\t\t\t\t\t// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n\t\t\t\t\t\t\t// extremely large values\n\t\t\t\t\t\t\tif ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {\n\n\t\t\t\t\t\t\t\tobject.lookAt( scope.target );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );\n\t\t\t\t\t\t\t\t_ray.intersectPlane( _plane, scope.target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );\n\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tperformCursorZoom = false;\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||\n\t\t\t\t\tlastTargetPosition.distanceToSquared( scope.target ) > 0 ) {\n\n\t\t\t\t\tscope.dispatchEvent( _changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tlastTargetPosition.copy( scope.target );\n\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function () {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu );\n\n\t\t\tscope.domElement.removeEventListener( 'pointerdown', onPointerDown );\n\t\t\tscope.domElement.removeEventListener( 'pointercancel', onPointerUp );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel );\n\n\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\n\t\t\tif ( scope._domElementKeyEvents !== null ) {\n\n\t\t\t\tscope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );\n\t\t\t\tscope._domElementKeyEvents = null;\n\n\t\t\t}\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tconst scope = this;\n\n\t\tconst STATE = {\n\t\t\tNONE: - 1,\n\t\t\tROTATE: 0,\n\t\t\tDOLLY: 1,\n\t\t\tPAN: 2,\n\t\t\tTOUCH_ROTATE: 3,\n\t\t\tTOUCH_PAN: 4,\n\t\t\tTOUCH_DOLLY_PAN: 5,\n\t\t\tTOUCH_DOLLY_ROTATE: 6\n\t\t};\n\n\t\tlet state = STATE.NONE;\n\n\t\tconst EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tconst spherical = new Spherical();\n\t\tconst sphericalDelta = new Spherical();\n\n\t\tlet scale = 1;\n\t\tconst panOffset = new Vector3();\n\n\t\tconst rotateStart = new Vector2();\n\t\tconst rotateEnd = new Vector2();\n\t\tconst rotateDelta = new Vector2();\n\n\t\tconst panStart = new Vector2();\n\t\tconst panEnd = new Vector2();\n\t\tconst panDelta = new Vector2();\n\n\t\tconst dollyStart = new Vector2();\n\t\tconst dollyEnd = new Vector2();\n\t\tconst dollyDelta = new Vector2();\n\n\t\tconst dollyDirection = new Vector3();\n\t\tconst mouse = new Vector2();\n\t\tlet performCursorZoom = false;\n\n\t\tconst pointers = [];\n\t\tconst pointerPositions = {};\n\n\t\tfunction getAutoRotationAngle( deltaTime ) {\n\n\t\t\tif ( deltaTime !== null ) {\n\n\t\t\t\treturn ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;\n\n\t\t\t} else {\n\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tconst panLeft = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tconst panUp = function () {\n\n\t\t\tconst v = new Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tif ( scope.screenSpacePanning === true ) {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 );\n\t\t\t\t\tv.crossVectors( scope.object.up, v );\n\n\t\t\t\t}\n\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tconst pan = function () {\n\n\t\t\tconst offset = new Vector3();\n\n\t\t\treturn function pan( deltaX, deltaY ) {\n\n\t\t\t\tconst element = scope.domElement;\n\n\t\t\t\tif ( scope.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tconst position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tlet targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object.isOrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateMouseParameters( event ) {\n\n\t\t\tif ( ! scope.zoomToCursor ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tperformCursorZoom = true;\n\n\t\t\tconst rect = scope.domElement.getBoundingClientRect();\n\t\t\tconst x = event.clientX - rect.left;\n\t\t\tconst y = event.clientY - rect.top;\n\t\t\tconst w = rect.width;\n\t\t\tconst h = rect.height;\n\n\t\t\tmouse.x = ( x / w ) * 2 - 1;\n\t\t\tmouse.y = - ( y / h ) * 2 + 1;\n\n\t\t\tdollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();\n\n\t\t}\n\n\t\tfunction clampDistance( dist ) {\n\n\t\t\treturn Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\tupdateMouseParameters( event );\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\tupdateMouseParameters( event );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\tlet needsUpdate = false;\n\n\t\t\tswitch ( event.code ) {\n\n\t\t\t\tcase scope.keys.UP:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\trotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\tscope.update();\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\trotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\trotateStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartPan() {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );\n\t\t\t\tconst y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );\n\n\t\t\t\tpanStart.set( x, y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly() {\n\n\t\t\tconst dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;\n\t\t\tconst dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyPan() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enablePan ) handleTouchStartPan();\n\n\t\t}\n\n\t\tfunction handleTouchStartDollyRotate() {\n\n\t\t\tif ( scope.enableZoom ) handleTouchStartDolly();\n\n\t\t\tif ( scope.enableRotate ) handleTouchStartRotate();\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\tif ( pointers.length == 1 ) {\n\n\t\t\t\trotateEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\trotateEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );\n\n\t\t\tconst element = scope.domElement;\n\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height\n\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\tif ( pointers.length === 1 ) {\n\n\t\t\t\tpanEnd.set( event.pageX, event.pageY );\n\n\t\t\t} else {\n\n\t\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\t\tconst x = 0.5 * ( event.pageX + position.x );\n\t\t\t\tconst y = 0.5 * ( event.pageY + position.y );\n\n\t\t\t\tpanEnd.set( x, y );\n\n\t\t\t}\n\n\t\t\tpanDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\tconst position = getSecondPointerPosition( event );\n\n\t\t\tconst dx = event.pageX - position.x;\n\t\t\tconst dy = event.pageY - position.y;\n\n\t\t\tconst distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );\n\n\t\t\tdollyOut( dollyDelta.y );\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyPan( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enablePan ) handleTouchMovePan( event );\n\n\t\t}\n\n\t\tfunction handleTouchMoveDollyRotate( event ) {\n\n\t\t\tif ( scope.enableZoom ) handleTouchMoveDolly( event );\n\n\t\t\tif ( scope.enableRotate ) handleTouchMoveRotate( event );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onPointerDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.setPointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.addEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.addEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\taddPointer( event );\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchStart( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseDown( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tif ( event.pointerType === 'touch' ) {\n\n\t\t\t\tonTouchMove( event );\n\n\t\t\t} else {\n\n\t\t\t\tonMouseMove( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onPointerUp( event ) {\n\n\t\t\tremovePointer( event );\n\n\t\t\tif ( pointers.length === 0 ) {\n\n\t\t\t\tscope.domElement.releasePointerCapture( event.pointerId );\n\n\t\t\t\tscope.domElement.removeEventListener( 'pointermove', onPointerMove );\n\t\t\t\tscope.domElement.removeEventListener( 'pointerup', onPointerUp );\n\n\t\t\t}\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tlet mouseAction;\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tmouseAction = - 1;\n\n\t\t\t}\n\n\t\t\tswitch ( mouseAction ) {\n\n\t\t\t\tcase MOUSE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.ROTATE:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MOUSE.PAN:\n\n\t\t\t\t\tif ( event.ctrlKey || event.metaKey || event.shiftKey ) {\n\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.DOLLY:\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( _endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( pointers.length ) {\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\tswitch ( scope.touches.ONE ) {\n\n\t\t\t\t\t\tcase TOUCH.ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.PAN:\n\n\t\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\tswitch ( scope.touches.TWO ) {\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyPan();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\t\t\thandleTouchStartDollyRotate();\n\n\t\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( _startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\ttrackPointer( event );\n\n\t\t\tswitch ( state ) {\n\n\t\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyPan( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\t\tif ( scope.enableZoom === false && scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchMoveDollyRotate( event );\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tfunction addPointer( event ) {\n\n\t\t\tpointers.push( event );\n\n\t\t}\n\n\t\tfunction removePointer( event ) {\n\n\t\t\tdelete pointerPositions[ event.pointerId ];\n\n\t\t\tfor ( let i = 0; i < pointers.length; i ++ ) {\n\n\t\t\t\tif ( pointers[ i ].pointerId == event.pointerId ) {\n\n\t\t\t\t\tpointers.splice( i, 1 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction trackPointer( event ) {\n\n\t\t\tlet position = pointerPositions[ event.pointerId ];\n\n\t\t\tif ( position === undefined ) {\n\n\t\t\t\tposition = new Vector2();\n\t\t\t\tpointerPositions[ event.pointerId ] = position;\n\n\t\t\t}\n\n\t\t\tposition.set( event.pageX, event.pageY );\n\n\t\t}\n\n\t\tfunction getSecondPointerPosition( event ) {\n\n\t\t\tconst pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];\n\n\t\t\treturn pointerPositions[ pointer.pointerId ];\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu );\n\n\t\tscope.domElement.addEventListener( 'pointerdown', onPointerDown );\n\t\tscope.domElement.addEventListener( 'pointercancel', onPointerUp );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t}\n\n}\n\nexport { OrbitControls };\n", "/* eslint-disable init-declarations */\nimport { Camera, Euler, Vector3 } from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n\nexport { OrbitControls }\n\nexport type Transform = { position: Vector3, rotation: Euler }\n\ntype Check = (current: Transform, previous: Transform | undefined) => Promise<boolean | unknown>\ntype Updated = (current: Transform, previous: Transform | undefined) => Promise<boolean | unknown>\n\nexport function orbitControlsRestrictor(orbit: OrbitControls, camera: Camera, check: Check, updated: Updated) {\n  let previous: Transform | undefined\n  let previousTarget: Vector3\n\n  // eslint-disable-next-line max-statements\n  orbit.addEventListener('change', async () => {\n    const position = camera.position.clone()\n    const rotation = camera.rotation.clone()\n\n    if (await check({ position, rotation }, previous)) {\n      previous = { position, rotation }\n      previousTarget = orbit.target.clone()\n    } else {\n      if (previous && previousTarget) {\n        const { position: p, rotation: r } = previous\n        const t = previousTarget\n\n        camera.position.fromArray([p.x, p.y, p.z])\n        camera.rotation.fromArray([r.x, r.y, r.z])\n        orbit.target.fromArray([t.x, t.y, t.z])\n      }\n      orbit.update()\n      await updated({ position, rotation }, previous)\n    }\n  })\n}\n", "import {\n  Object3D, PerspectiveCamera, Plane,\n  Raycaster, Scene, Vector2, Vector3\n} from 'three'\n\nimport { attachDraggableHooks, DragControls, DraggableObject3D } from './Drag'\nimport { HybridRenderer } from './HybridRenderer'\nimport { OrbitControls } from './OrbitControls'\n\nexport { DraggableObject3D }\n\ntype DefaultObject3D = Object3D\n\n/**\n * HybridScene is a wrapper for Three.js Scene with some additional features such as:\n * - drag controls\n * - orbit controls\n * - camera\n * - renderer\n */\nexport class HybridScene<Scope> {\n  camera: PerspectiveCamera\n  renderer: HybridRenderer\n  root = new Scene()\n  canvases = new Map<Scope, DefaultObject3D>()\n  controls: DragControls\n  orbit: OrbitControls\n\n  constructor(private container: HTMLElement) {\n    this.camera = new PerspectiveCamera()\n    this.camera.position.set(0, 0, 1000)\n    this.camera.fov = 45\n    this.camera.near = 1\n    this.camera.far = 4000\n\n    this.renderer = new HybridRenderer()\n\n    container.appendChild(this.renderer.domElement)\n\n    this.orbit = this.createOrbitControls()\n    this.controls = this.createDragControls(this.orbit)\n  }\n\n  private createOrbitControls() {\n    const orbit = new OrbitControls(this.camera, this.renderer.domElement)\n\n    orbit.update()\n\n    let orbitChangeNumber = 0\n\n    orbit.addEventListener('start', () => {\n      orbitChangeNumber = 0\n    })\n\n    orbit.addEventListener('change', () => {\n      orbitChangeNumber++\n    })\n\n    this.renderer.domElement.addEventListener('contextmenu', e => {\n      if (orbitChangeNumber > 5) e.stopPropagation()\n    })\n\n    return orbit\n  }\n\n  private createDragControls(orbit: OrbitControls) {\n    const controls = new DragControls(\n      this.camera,\n      this.renderer.domElement,\n      (object) => {\n        const canvas = object.parent\n\n        if (!canvas) throw new Error('object doesnt have parent')\n        if (!Array.from(this.canvases.values()).includes(canvas)) throw new Error('object parent isnt canvas')\n\n        return this.canvasToPlane(canvas)\n      }\n    )\n\n    attachDraggableHooks(controls)\n\n    controls.addEventListener('dragstart', () => orbit.enabled = false)\n    controls.addEventListener('dragend', () => orbit.enabled = true)\n\n    return controls\n  }\n\n  canvasToPlane(canvas: Object3D) {\n    const plane = new Plane()\n    const normal = new Vector3(0, 0, 1)\n\n    normal.applyQuaternion(canvas.quaternion)\n    plane.setFromNormalAndCoplanarPoint(normal, canvas.position.clone())\n\n    return plane\n  }\n\n  addCanvasFor(scope: Scope) {\n    const canvas = new Object3D()\n\n    canvas.scale.set(1, -1, 1)\n    this.canvases.set(scope, canvas)\n    this.root.add(canvas)\n  }\n\n  resize(width: number, height: number) {\n    this.camera.aspect = width / height\n    this.camera.updateProjectionMatrix()\n    this.renderer.setSize(width, height)\n  }\n\n  /**\n   * Render the frame. Can be directly used instead of `animate` extension.\n   */\n  public render() {\n    this.renderer.render(this.root, this.camera)\n  }\n\n  private getCanvasFor(scope: Scope) {\n    const canvas = this.canvases.get(scope)\n\n    if (!canvas) throw new Error('cannot find canvas for the scope')\n\n    return canvas\n  }\n\n  add(object: Object3D, scope: Scope) {\n    object.scale.set(1, -1, 1)\n    this.getCanvasFor(scope).add(object)\n    if (object instanceof DraggableObject3D) this.controls.attach(object)\n    this.render() // force DOM elements to be rendered synchronously\n  }\n\n  remove(object: Object3D, scope: Scope) {\n    this.getCanvasFor(scope).remove(object)\n    if (object instanceof DraggableObject3D) this.controls.detach(object)\n    this.render() // force DOM elements to be rendered synchronously\n  }\n\n  public getPointerFrom(event: MouseEvent, scope: Scope) {\n    const rect = this.container.getBoundingClientRect()\n    const raycaster = new Raycaster()\n    const pointer = new Vector2(\n      (event.clientX - rect.left) / rect.width * 2 - 1,\n      - (event.clientY - rect.top) / rect.height * 2 + 1\n    )\n\n    raycaster.setFromCamera(pointer, this.camera)\n\n    const canvas = this.getCanvasFor(scope)\n    const plane = this.canvasToPlane(canvas)\n\n    const intersection = raycaster.ray.intersectPlane(plane, new Vector3())\n\n    if (intersection) {\n      return canvas.worldToLocal(intersection)\n    }\n    return null\n  }\n}\n", "import { Object3D } from 'three'\nimport { Content } from './content'\nimport { HybridScene } from './scene'\nimport { orbitControlsRestrictor } from './scene/OrbitControls'\nimport { Position, Vector3D } from './types'\n\nexport type Transform = { position: Vector3D, rotation: Vector3D }\nexport type TransformEventParams = { previous: Transform | undefined, current: Transform }\n\ntype Events = {\n  pointerDown: (position: Position, event: PointerEvent) => void\n  pointerMove: (position: Position, event: PointerEvent) => void\n  pointerUp: (position: Position, event: PointerEvent) => void\n  resize: (event: Event) => void\n  transformed: (params: TransformEventParams) => Promise<unknown>\n  reordered: (element: HTMLElement) => Promise<unknown>\n}\ntype Guards = {\n  transform: (params: TransformEventParams) => Promise<unknown | boolean>\n}\n\n/**\n * Area class is responsible for managing 3D scene for a current editor\n */\nexport class Area<Scope> {\n  scene: HybridScene<Scope>\n  pointer: Position = { x: 0, y: 0 }\n\n  content: Content<Scope>\n\n  constructor(private container: HTMLElement, scene: HybridScene<Scope> | null, private scope: Scope, private events: Events, private guards: Guards) {\n    this.scene = scene || new HybridScene(this.container)\n    this.content = new Content(this.scene, scope, element => this.events.reordered(element))\n\n    this.container.addEventListener('pointerdown', this.pointerdown)\n    this.container.addEventListener('pointermove', this.pointermove)\n    window.addEventListener('pointerup', this.pointerup)\n    window.addEventListener('resize', this.resize)\n\n    orbitControlsRestrictor(\n      this.scene.orbit,\n      this.scene.camera,\n      (current, previous) => this.guards.transform({ previous, current }),\n      (current, previous) => this.events.transformed({ previous, current })\n    )\n\n    this.scene.resize(this.container.clientWidth, this.container.clientHeight)\n  }\n\n  /**\n   * Get the canvas in form of Object3D for the current scope\n   */\n  public getCanvas(): Object3D | undefined {\n    return this.scene.canvases.get(this.scope)\n  }\n\n  /**\n   * Set the pointer position from the given mouse event into the `pointer` property\n   */\n  public setPointerFrom(event: MouseEvent) {\n    const point = this.scene.getPointerFrom(event, this.scope)\n\n    if (point) {\n      this.pointer = {\n        x: point.x,\n        y: point.y\n      }\n    }\n  }\n\n  private pointerdown = (event: PointerEvent) => {\n    this.setPointerFrom(event)\n    this.events.pointerDown(this.pointer, event)\n  }\n\n  private pointermove = (event: PointerEvent) => {\n    this.setPointerFrom(event)\n    this.events.pointerMove(this.pointer, event)\n  }\n\n  private pointerup = (event: PointerEvent) => {\n    this.setPointerFrom(event)\n    this.events.pointerUp(this.pointer, event)\n  }\n\n  /**\n   * Force resize the container of the 3D scene\n   * @param event The resize event\n   */\n  public resize = (event: Event) => {\n    this.events.resize(event)\n    this.scene.resize(this.container.clientWidth, this.container.clientHeight)\n  }\n\n  public destroy() {\n    this.container.removeEventListener('pointerdown', this.pointerdown)\n    this.container.removeEventListener('pointermove', this.pointermove)\n    window.removeEventListener('pointerup', this.pointerup)\n    window.removeEventListener('resize', this.resize)\n  }\n}\n", "import { ObjectHTML } from './scene/ObjectHTML'\n\ntype Events = {\n  contextmenu: (event: MouseEvent) => void\n}\n\nexport class ConnectionView {\n  element: HTMLElement\n  object: ObjectHTML\n\n  constructor(events: Events) {\n    this.element = document.createElement('div')\n\n    this.element.style.position = 'absolute'\n    this.element.style.left = '0'\n    this.element.style.top = '0'\n    this.element.addEventListener('contextmenu', event => events.contextmenu(event))\n\n    this.object = new ObjectHTML(this.element)\n  }\n\n  // public update(params?: HTML3DOptions) {\n  //   setHTMLElement(this.object, this.element, {\n  //     materials: {\n  //       front: params?.materials?.front || createMaterial(false),\n  //       back: params?.materials?.back || createBackMaterial()\n  //     }\n  //   })\n  // }\n}\n", "\nexport class ElementsHolder<E extends HTMLElement, Ctx extends { type: string, element: E, payload?: { id: string } }> {\n  views = new WeakMap<E, Ctx>()\n  viewsElements = new Map<`${string}_${string}`, E>()\n\n  public set(context: Ctx) {\n    const { element, type, payload } = context\n\n    if (payload?.id) {\n      this.views.set(element, context)\n      this.viewsElements.set(`${type}_${payload.id}`, element)\n    }\n  }\n\n  public get(type: string, id: string) {\n    const element = this.viewsElements.get(`${type}_${id}`)\n\n    return element && this.views.get(element)\n  }\n\n  public delete(element: E) {\n    const view = this.views.get(element)\n\n    if (view && view.payload?.id) {\n      this.views.delete(element)\n      this.viewsElements.delete(`${view.type}_${view.payload.id}`)\n    }\n  }\n}\n", "import { DraggableObject3D } from './scene'\nimport { ObjectHTML } from './scene/ObjectHTML'\nimport { Position, Size } from './types'\n\nexport type NodeTranslateEventParams = { position: Position, previous: Position }\nexport type NodeResizeEventParams = { size: Size }\n\ntype Events = {\n  picked: () => void\n  translated: (params: NodeTranslateEventParams) => Promise<unknown | boolean>\n  dragged: () => void\n  contextmenu: (event: MouseEvent) => void\n  resized: (params: NodeResizeEventParams) => Promise<unknown | boolean>\n}\ntype Guards = {\n  resize: (params: NodeResizeEventParams) => Promise<unknown | boolean>\n  translate: (params: NodeTranslateEventParams) => Promise<unknown | boolean>\n}\n\nexport class NodeView {\n  element: HTMLElement\n  object: ObjectHTML\n  position: Position\n\n  constructor(private events: Events, private guards: Guards) {\n    this.element = document.createElement('div')\n    this.element.style.position = 'absolute'\n    this.position = { x: 0, y: 0 }\n    this.translate(0, 0)\n\n    this.element.addEventListener('contextmenu', event => this.events.contextmenu(event))\n\n    this.object = new DraggableObject3D(this.element, {\n      start: this.events.picked,\n      translate: this.translate,\n      drag: this.events.dragged\n    })\n  }\n\n  public translate = async (x: number, y: number) => {\n    type Params = undefined | { data: NodeTranslateEventParams }\n    const previous = { ...this.position }\n    const translation = await this.guards.translate({ previous, position: { x, y } }) as Params\n\n    if (!translation) return false\n\n    this.position = { ...translation.data.position }\n    this.object.position.set(this.position.x, this.position.y, this.object.position.z)\n\n    await this.events.translated({ position: this.position, previous })\n\n    return true\n  }\n\n  public resize = async (width: number, height: number) => {\n    const size = { width, height }\n\n    if (!(await this.guards.resize({ size }))) return false\n\n    const el = this.element.children.item(0)\n\n    if (!el || !(el instanceof HTMLElement)) return false\n\n    el.style.width = `${width}px`\n    el.style.height = `${height}px`\n\n    await this.events.resized({ size })\n\n    return true\n  }\n\n  public destroy() {\n    null\n  }\n}\n", "import { Area3DPlugin } from '..'\nimport { ExpectSchemes } from '../types'\n\n/**\n * Animate the given 3D scene, uses `requestAnimationFrame`\n * @param area The 3D area plugin\n * @param tick Optional callback to be called on each frame\n * @example Area3DExtensions.animate(area)\n * @example Area3DExtensions.animate(area, time => console.log(time))\n */\nexport function animate<S extends ExpectSchemes, K>(area: Area3DPlugin<S, K>, tick?: (time: number) => void) {\n  function render(time: number) {\n    if (tick) tick(time)\n\n    area.area.scene.render()\n    requestAnimationFrame((t) => render(t))\n  }\n\n  render(performance.now())\n}\n", "import { Shape } from 'three'\n\n// eslint-disable-next-line max-statements\nexport function getRoundedShape(width: number, height: number, radius: number) {\n  const shape = new Shape()\n  const x = 0\n  const y = 0\n\n  shape.moveTo(x + radius, y)\n  shape.lineTo(x + width - radius, y)\n  shape.quadraticCurveTo(x + width, y, x + width, y + radius)\n  shape.lineTo(x + width, y + height - radius)\n  shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)\n  shape.lineTo(x + radius, y + height)\n  shape.quadraticCurveTo(x, y + height, x, y + height - radius)\n  shape.lineTo(x, y + radius)\n  shape.quadraticCurveTo(x, y, x + radius, y)\n  shape.closePath()\n\n  return shape\n}\n", "import { ConnectionId, NodeId, Scope, ScopeAsParameter } from 'rete'\nimport { BufferGeometry, ShapeGeometry } from 'three'\n\nimport { Area3DPlugin } from '../..'\nimport { ExpectSchemes, Position } from '../../types'\nimport { getRoundedShape } from '../../utils/shapes'\n\nexport type Pin = {\n  id: string\n  position: Position\n  selected?: boolean\n}\nexport type PinData = {\n  id: ConnectionId\n  pins: Pin[]\n}\n\ntype Comment = {\n  element: HTMLElement\n  id: string\n  width: number\n  height: number\n  x: number\n  y: number\n}\n\ntype Requires =\n  | { type: 'commentcreated', data: Comment }\n  | { type: 'commentremoved', data: Comment }\n  | { type: 'editcomment', data: Comment }\n  | { type: 'commentselected', data: Comment }\n  | { type: 'commentunselected', data: Comment }\n  | { type: 'commenttranslated', data: { id: Comment['id'], dx: number, dy: number, sources?: NodeId[] } }\n  | { type: 'commentlinktranslate', data: { id: Comment['id'], link: string } }\n\n/**\n * Form generator for embedding rete-comment-plugin into 3D scene.\n * @param scope Area3DPlugin instance\n */\nexport function comment<S extends ExpectSchemes, K>(scope: ScopeAsParameter<Scope<K, any[]>, [Requires]>) {\n  const commentScope = scope as unknown as Scope<Requires> & {\n    comments: Map<string, Comment>\n  }\n  const area = commentScope.parentScope<Area3DPlugin<S, any>>(Area3DPlugin)\n\n  commentScope.addPipe(context => {\n    if (context.type === 'commentcreated') {\n      updateCommentGeometry(area, context.data)\n    }\n    if (context.type === 'commenttranslated') {\n      const { id } = context.data\n      const c = commentScope.comments.get(id)\n\n      if (c) {\n        updateCommentGeometry(area, c)\n      }\n    }\n    return context\n  })\n}\n\ntype CommentGeometry = BufferGeometry & {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __commentGeometry?: {\n    width: number\n    height: number\n    x: number\n    y: number\n  }\n}\n\nfunction commentGeometry(width: number, height: number, x: number, y: number) {\n  const shape = getRoundedShape(width, height, 18)\n  const geometry = new ShapeGeometry(shape) as CommentGeometry\n\n  geometry.__commentGeometry = {\n    width,\n    height,\n    x,\n    y\n  }\n\n  geometry.translate(x, y, 0)\n\n  return geometry\n}\n\nfunction updateCommentGeometry(area: Area3DPlugin<ExpectSchemes, any>, c: Comment) {\n  area.area.content.updateGeometry(c.element, existing => {\n    const meta = (existing as CommentGeometry)?.__commentGeometry\n\n    if (meta) {\n      if (meta.width !== c.width || meta.height !== c.height) {\n        return commentGeometry(c.width, c.height, c.x, c.y)\n      }\n      if (meta.x !== c.x || meta.y !== c.y) {\n        return existing?.translate(c.x - meta.x, c.y - meta.y, 0)\n      }\n    }\n    return commentGeometry(c.width, c.height, c.x, c.y)\n  })\n}\n", "\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "function clone(point) { //TODO: use gl-vec2 for this\n    return [point[0], point[1]]\n}\n\nfunction vec2(x, y) {\n    return [x, y]\n}\n\nmodule.exports = function createBezierBuilder(opt) {\n    opt = opt||{}\n\n    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8\n    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7\n    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0\n\n    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01\n    var m_angle_tolerance = opt.angleTolerance || 0\n    var m_cusp_limit = opt.cuspLimit || 0\n\n    return function bezierCurve(start, c1, c2, end, scale, points) {\n        if (!points)\n            points = []\n\n        scale = typeof scale === 'number' ? scale : 1.0\n        var distanceTolerance = PATH_DISTANCE_EPSILON / scale\n        distanceTolerance *= distanceTolerance\n        begin(start, c1, c2, end, points, distanceTolerance)\n        return points\n    }\n\n\n    ////// Based on:\n    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\n    function begin(start, c1, c2, end, points, distanceTolerance) {\n        points.push(clone(start))\n        var x1 = start[0],\n            y1 = start[1],\n            x2 = c1[0],\n            y2 = c1[1],\n            x3 = c2[0],\n            y3 = c2[1],\n            x4 = end[0],\n            y4 = end[1]\n        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)\n        points.push(clone(end))\n    }\n\n    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n        if(level > RECURSION_LIMIT) \n            return\n\n        var pi = Math.PI\n\n        // Calculate all the mid-points of the line segments\n        //----------------------\n        var x12   = (x1 + x2) / 2\n        var y12   = (y1 + y2) / 2\n        var x23   = (x2 + x3) / 2\n        var y23   = (y2 + y3) / 2\n        var x34   = (x3 + x4) / 2\n        var y34   = (y3 + y4) / 2\n        var x123  = (x12 + x23) / 2\n        var y123  = (y12 + y23) / 2\n        var x234  = (x23 + x34) / 2\n        var y234  = (y23 + y34) / 2\n        var x1234 = (x123 + x234) / 2\n        var y1234 = (y123 + y234) / 2\n\n        if(level > 0) { // Enforce subdivision first time\n            // Try to approximate the full cubic curve by a single straight line\n            //------------------\n            var dx = x4-x1\n            var dy = y4-y1\n\n            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)\n            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)\n\n            var da1, da2\n\n            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n                // Regular care\n                //-----------------\n                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {\n                    // If the curvature doesn't exceed the distanceTolerance value\n                    // we tend to finish subdivisions.\n                    //----------------------\n                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {\n                        points.push(vec2(x1234, y1234))\n                        return\n                    }\n\n                    // Angle & Cusp Condition\n                    //----------------------\n                    var a23 = Math.atan2(y3 - y2, x3 - x2)\n                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))\n                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)\n                    if(da1 >= pi) da1 = 2*pi - da1\n                    if(da2 >= pi) da2 = 2*pi - da2\n\n                    if(da1 + da2 < m_angle_tolerance) {\n                        // Finally we can stop the recursion\n                        //----------------------\n                        points.push(vec2(x1234, y1234))\n                        return\n                    }\n\n                    if(m_cusp_limit !== 0.0) {\n                        if(da1 > m_cusp_limit) {\n                            points.push(vec2(x2, y2))\n                            return\n                        }\n\n                        if(da2 > m_cusp_limit) {\n                            points.push(vec2(x3, y3))\n                            return\n                        }\n                    }\n                }\n            }\n            else {\n                if(d2 > FLT_EPSILON) {\n                    // p1,p3,p4 are collinear, p2 is considerable\n                    //----------------------\n                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {\n                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {\n                            points.push(vec2(x1234, y1234))\n                            return\n                        }\n\n                        // Angle Condition\n                        //----------------------\n                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))\n                        if(da1 >= pi) da1 = 2*pi - da1\n\n                        if(da1 < m_angle_tolerance) {\n                            points.push(vec2(x2, y2))\n                            points.push(vec2(x3, y3))\n                            return\n                        }\n\n                        if(m_cusp_limit !== 0.0) {\n                            if(da1 > m_cusp_limit) {\n                                points.push(vec2(x2, y2))\n                                return\n                            }\n                        }\n                    }\n                }\n                else if(d3 > FLT_EPSILON) {\n                    // p1,p2,p4 are collinear, p3 is considerable\n                    //----------------------\n                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {\n                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {\n                            points.push(vec2(x1234, y1234))\n                            return\n                        }\n\n                        // Angle Condition\n                        //----------------------\n                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))\n                        if(da1 >= pi) da1 = 2*pi - da1\n\n                        if(da1 < m_angle_tolerance) {\n                            points.push(vec2(x2, y2))\n                            points.push(vec2(x3, y3))\n                            return\n                        }\n\n                        if(m_cusp_limit !== 0.0) {\n                            if(da1 > m_cusp_limit)\n                            {\n                                points.push(vec2(x3, y3))\n                                return\n                            }\n                        }\n                    }\n                }\n                else {\n                    // Collinear case\n                    //-----------------\n                    dx = x1234 - (x1 + x4) / 2\n                    dy = y1234 - (y1 + y4) / 2\n                    if(dx*dx + dy*dy <= distanceTolerance) {\n                        points.push(vec2(x1234, y1234))\n                        return\n                    }\n                }\n            }\n        }\n\n        // Continue subdivision\n        //----------------------\n        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) \n        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) \n    }\n}\n", "module.exports = require('./function')()", "\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n", "\nvar  = Math.PI\nvar _120 = radians(120)\n\nmodule.exports = normalize\n\n/**\n * describe `path` in terms of cubic bzier \n * curves and move commands\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction normalize(path){\n\t// init state\n\tvar prev\n\tvar result = []\n\tvar bezierX = 0\n\tvar bezierY = 0\n\tvar startX = 0\n\tvar startY = 0\n\tvar quadX = null\n\tvar quadY = null\n\tvar x = 0\n\tvar y = 0\n\n\tfor (var i = 0, len = path.length; i < len; i++) {\n\t\tvar seg = path[i]\n\t\tvar command = seg[0]\n\t\tswitch (command) {\n\t\t\tcase 'M':\n\t\t\t\tstartX = seg[1]\n\t\t\t\tstartY = seg[2]\n\t\t\t\tbreak\n\t\t\tcase 'A':\n\t\t\t\tseg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7])\n\t\t\t\t// split multi part\n\t\t\t\tseg.unshift('C')\n\t\t\t\tif (seg.length > 7) {\n\t\t\t\t\tresult.push(seg.splice(0, 7))\n\t\t\t\t\tseg.unshift('C')\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'S':\n\t\t\t\t// default control point\n\t\t\t\tvar cx = x\n\t\t\t\tvar cy = y\n\t\t\t\tif (prev == 'C' || prev == 'S') {\n\t\t\t\t\tcx += cx - bezierX // reflect the previous command's control\n\t\t\t\t\tcy += cy - bezierY // point relative to the current point\n\t\t\t\t}\n\t\t\t\tseg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]\n\t\t\t\tbreak\n\t\t\tcase 'T':\n\t\t\t\tif (prev == 'Q' || prev == 'T') {\n\t\t\t\t\tquadX = x * 2 - quadX // as with 'S' reflect previous control point\n\t\t\t\t\tquadY = y * 2 - quadY\n\t\t\t\t} else {\n\t\t\t\t\tquadX = x\n\t\t\t\t\tquadY = y\n\t\t\t\t}\n\t\t\t\tseg = quadratic(x, y, quadX, quadY, seg[1], seg[2])\n\t\t\t\tbreak\n\t\t\tcase 'Q':\n\t\t\t\tquadX = seg[1]\n\t\t\t\tquadY = seg[2]\n\t\t\t\tseg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])\n\t\t\t\tbreak\n\t\t\tcase 'L':\n\t\t\t\tseg = line(x, y, seg[1], seg[2])\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tseg = line(x, y, seg[1], y)\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\tseg = line(x, y, x, seg[1])\n\t\t\t\tbreak\n\t\t\tcase 'Z':\n\t\t\t\tseg = line(x, y, startX, startY)\n\t\t\t\tbreak\n\t\t}\n\n\t\t// update state\n\t\tprev = command\n\t\tx = seg[seg.length - 2]\n\t\ty = seg[seg.length - 1]\n\t\tif (seg.length > 4) {\n\t\t\tbezierX = seg[seg.length - 4]\n\t\t\tbezierY = seg[seg.length - 3]\n\t\t} else {\n\t\t\tbezierX = x\n\t\t\tbezierY = y\n\t\t}\n\t\tresult.push(seg)\n\t}\n\n\treturn result\n}\n\nfunction line(x1, y1, x2, y2){\n\treturn ['C', x1, y1, x2, y2, x2, y2]\n}\n\nfunction quadratic(x1, y1, cx, cy, x2, y2){\n\treturn [\n\t\t'C',\n\t\tx1/3 + (2/3) * cx,\n\t\ty1/3 + (2/3) * cy,\n\t\tx2/3 + (2/3) * cx,\n\t\ty2/3 + (2/3) * cy,\n\t\tx2,\n\t\ty2\n\t]\n}\n\n// This function is ripped from \n// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 \n// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n// TODO: make it human readable\n\nfunction arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\tif (!recursive) {\n\t\tvar xy = rotate(x1, y1, -angle)\n\t\tx1 = xy.x\n\t\ty1 = xy.y\n\t\txy = rotate(x2, y2, -angle)\n\t\tx2 = xy.x\n\t\ty2 = xy.y\n\t\tvar x = (x1 - x2) / 2\n\t\tvar y = (y1 - y2) / 2\n\t\tvar h = (x * x) / (rx * rx) + (y * y) / (ry * ry)\n\t\tif (h > 1) {\n\t\t\th = Math.sqrt(h)\n\t\t\trx = h * rx\n\t\t\try = h * ry\n\t\t}\n\t\tvar rx2 = rx * rx\n\t\tvar ry2 = ry * ry\n\t\tvar k = (large_arc_flag == sweep_flag ? -1 : 1)\n\t\t\t* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)))\n\t\tif (k == Infinity) k = 1 // neutralize\n\t\tvar cx = k * rx * y / ry + (x1 + x2) / 2\n\t\tvar cy = k * -ry * x / rx + (y1 + y2) / 2\n\t\tvar f1 = Math.asin(((y1 - cy) / ry).toFixed(9))\n\t\tvar f2 = Math.asin(((y2 - cy) / ry).toFixed(9))\n\n\t\tf1 = x1 < cx ?  - f1 : f1\n\t\tf2 = x2 < cx ?  - f2 : f2\n\t\tif (f1 < 0) f1 =  * 2 + f1\n\t\tif (f2 < 0) f2 =  * 2 + f2\n\t\tif (sweep_flag && f1 > f2) f1 = f1 -  * 2\n\t\tif (!sweep_flag && f2 > f1) f2 = f2 -  * 2\n\t} else {\n\t\tf1 = recursive[0]\n\t\tf2 = recursive[1]\n\t\tcx = recursive[2]\n\t\tcy = recursive[3]\n\t}\n\t// greater than 120 degrees requires multiple segments\n\tif (Math.abs(f2 - f1) > _120) {\n\t\tvar f2old = f2\n\t\tvar x2old = x2\n\t\tvar y2old = y2\n\t\tf2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1)\n\t\tx2 = cx + rx * Math.cos(f2)\n\t\ty2 = cy + ry * Math.sin(f2)\n\t\tvar res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy])\n\t}\n\tvar t = Math.tan((f2 - f1) / 4)\n\tvar hx = 4 / 3 * rx * t\n\tvar hy = 4 / 3 * ry * t\n\tvar curve = [\n\t\t2 * x1 - (x1 + hx * Math.sin(f1)),\n\t\t2 * y1 - (y1 - hy * Math.cos(f1)),\n\t\tx2 + hx * Math.sin(f2),\n\t\ty2 - hy * Math.cos(f2),\n\t\tx2,\n\t\ty2\n\t]\n\tif (recursive) return curve\n\tif (res) curve = curve.concat(res)\n\tfor (var i = 0; i < curve.length;) {\n\t\tvar rot = rotate(curve[i], curve[i+1], angle)\n\t\tcurve[i++] = rot.x\n\t\tcurve[i++] = rot.y\n\t}\n\treturn curve\n}\n\nfunction rotate(x, y, rad){\n\treturn {\n\t\tx: x * Math.cos(rad) - y * Math.sin(rad),\n\t\ty: x * Math.sin(rad) + y * Math.cos(rad)\n\t}\n}\n\nfunction radians(degress){\n\treturn degress * ( / 180)\n}\n", "module.exports = function vec2Copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    return out\n}", "var bezier = require('adaptive-bezier-curve')\nvar abs = require('abs-svg-path')\nvar norm = require('normalize-svg-path')\nvar copy = require('vec2-copy')\n\nfunction set(out, x, y) {\n    out[0] = x\n    out[1] = y\n    return out\n}\n\nvar tmp1 = [0,0],\n    tmp2 = [0,0],\n    tmp3 = [0,0]\n\nfunction bezierTo(points, scale, start, seg) {\n    bezier(start, \n        set(tmp1, seg[1], seg[2]), \n        set(tmp2, seg[3], seg[4]),\n        set(tmp3, seg[5], seg[6]), scale, points)\n}\n\nmodule.exports = function contours(svg, scale) {\n    var paths = []\n\n    var points = []\n    var pen = [0, 0]\n    norm(abs(svg)).forEach(function(segment, i, self) {\n        if (segment[0] === 'M') {\n            copy(pen, segment.slice(1))\n            if (points.length>0) {\n                paths.push(points)\n                points = []\n            }\n        } else if (segment[0] === 'C') {\n            bezierTo(points, scale, pen, segment)\n            set(pen, segment[5], segment[6])\n        } else {\n            throw new Error('illegal type in SVG: '+segment[0])\n        }\n    })\n    if (points.length>0)\n        paths.push(points)\n    return paths\n}", "/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-ignore\nimport parse from 'parse-svg-path'\n// @ts-ignore\nimport contours from 'svg-path-contours'\nimport { BufferGeometry, PlaneGeometry, Vector2 } from 'three'\n\n/**\n * Create geometry for classic connection.\n * Can be used in `customize` option.\n * @param path SVG path\n * @param width Connection width\n * @returns Connection geometry\n */\n// eslint-disable-next-line max-statements\nexport function createClassicConnectionGeometry(path: string, width: number): BufferGeometry {\n  const segments = contours(parse(path)) as [number, number][][]\n  const points = segments.map(segment => segment.map(([x, y]) => ({ x, y }))).flat()\n  const geometry: BufferGeometry = new PlaneGeometry(100, 10, points.length - 1, 1)\n\n  for (let i = 0; i < points.length; i++) {\n    const normal = new Vector2(0, width / 2)\n    const point = new Vector2(points[i].x, points[i].y)\n\n    if (i > 0 && i < points.length - 1) {\n      const prevPoint = new Vector2(points[i - 1].x, points[i - 1].y)\n      const nextPoint = new Vector2(points[i + 1].x, points[i + 1].y)\n      const vectorBetweenPoints = nextPoint.clone().sub(prevPoint)\n      const normalBetweenPoints = new Vector2(-vectorBetweenPoints.y, vectorBetweenPoints.x).clone().normalize()\n\n      normal.set(normalBetweenPoints.x, normalBetweenPoints.y).multiplyScalar(width / 2)\n    }\n\n    geometry.attributes.position.setX(i, point.x + normal.x)\n    geometry.attributes.position.setY(i, point.y + normal.y)\n\n    geometry.attributes.position.setX(i + points.length, point.x - normal.x)\n    geometry.attributes.position.setY(i + points.length, point.y - normal.y)\n  }\n\n  return geometry\n}\n", "import { BaseSchemes, Scope, ScopeAsParameter } from 'rete'\nimport { classicConnectionPath } from 'rete-render-utils'\nimport { BufferGeometry } from 'three'\n\nimport { Area3DPlugin } from '../../..'\nimport { ExpectSchemes } from '../../../types'\nimport { createClassicConnectionGeometry } from './geometry'\n\nexport { createClassicConnectionGeometry }\n\ntype Position = { x: number, y: number }\ntype Requires<Schemes extends BaseSchemes> =\n  | { type: 'connectionpath', data: { payload: Schemes['Connection'], path?: string, points: Position[] } }\n\n/**\n * Options for node form generator\n */\nexport type Props = {\n  /** Customize connection geometry */\n  customize?: (path: string) => BufferGeometry\n}\n\n/**\n * Form generator for embedding connections into 3D scene.\n * @param scope Area3DPlugin instance\n * @param props Options for connection form generator\n */\nexport function connection<S extends ExpectSchemes, K, E>(scope: ScopeAsParameter<Scope<K, E[]>, [Requires<S>]>, props?: Props) {\n  const renderScope = scope as Scope<Requires<S>, E[]>\n  const area = renderScope.parentScope<Area3DPlugin<S, Requires<S>>>(Area3DPlugin)\n  // const editor = area.parentScope<NodeEditor<S>>(NodeEditor)\n\n  renderScope.addPipe(context => {\n    if (!context || typeof context !== 'object' || !('type' in context)) return context\n\n    if (context.type === 'connectionpath') {\n      const { id } = context.data.payload\n      const view = area.connectionViews.get(id)\n\n      if (view) {\n        const path = context.data.path || classicConnectionPath(context.data.points as [Position, Position], 0.3)\n        const geometry = props?.customize ? props.customize(path) : createClassicConnectionGeometry(path, 4.6)\n\n        if (geometry) {\n          area.area.content.updateGeometry(view.element, geometry)\n        }\n      }\n    }\n    return context\n  })\n}\n", "import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import { BufferGeometry, CircleGeometry, ShapeGeometry } from 'three'\nimport { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js'\n\nimport { Size } from '../../../types'\nimport { getRoundedShape } from '../../../utils/shapes'\n\n/**\n * Classic node geometry parameters\n */\nexport type Params = {\n  /** Socket radius, default: 12.3 */\n  socketRadius?: number\n  /** Socket margin, default: 11.5 */\n  socketMargin?: number\n  /** Inputs offset relative to bottom, default: 15.5 */\n  inputsOffset?: number\n  /** Outputs offset relative to top, default: 44.5 */\n  outputsOffset?: number\n  /** Border radius, default: 10 */\n  borderRadius?: number\n}\n\n/**\n * Create classic node geometry\n * @param size Node size\n * @param params Geometry parameters\n * @returns Node geometry\n */\n// eslint-disable-next-line max-statements\nexport function createClassicNodeGeometry(size: Size, params?: Params): BufferGeometry {\n  const {\n    borderRadius = 10,\n    inputsOffset = 15.5,\n    outputsOffset = 44.5,\n    socketRadius = 12.3,\n    socketMargin = 11.5\n  } = params || {}\n  const fixWidth = size.width - 1 // hide border artifact\n  const fixHeight = size.height - 1 // hide border artifact\n  const shape = getRoundedShape(fixWidth, fixHeight, borderRadius * 1.05)\n  const geometry = new ShapeGeometry(shape)\n  const circle = new CircleGeometry(socketRadius, 16)\n\n  const extra: BufferGeometry[] = []\n\n  if ('inputs' in size) {\n    const inputs = Object.entries((size as any).inputs).length\n\n    for (let index = 0; index < inputs; index++) {\n      const geom = circle.clone()\n      const x = 1.5\n      const y = size.height - socketRadius - inputsOffset - ((socketRadius * 2 + socketMargin) * index)\n\n      geom.translate(x, y, 0)\n\n      extra.push(geom)\n    }\n  }\n  if ('outputs' in size) {\n    const outputs = Object.entries((size as any).outputs).length\n\n    for (let index = 0; index < outputs; index++) {\n      const geom = circle.clone()\n      const x = size.width - 1.5\n      const y = socketRadius + outputsOffset + ((socketRadius * 2 + socketMargin) * index)\n\n      geom.translate(x, y, 0)\n\n      extra.push(geom)\n    }\n  }\n\n  return mergeGeometries([...extra, geometry])\n}\n", "import { NodeEditor } from 'rete'\nimport { BufferGeometry } from 'three'\n\nimport { Area3DPlugin } from '../../..'\nimport { ExpectSchemes } from '../../../types'\nimport { createClassicNodeGeometry } from './geometry'\n\nexport { createClassicNodeGeometry }\n\n/**\n * Options for node form generator\n */\nexport type Props<S extends ExpectSchemes> = {\n  /** Customize node geometry */\n  customize?: (node: S['Node']) => BufferGeometry\n}\n\n/**\n * Form generator for embedding nodes into 3D scene.\n * @param area Area3DPlugin instance\n * @param props Options for node form generator\n */\nexport function node<S extends ExpectSchemes, K>(area: Area3DPlugin<S, K>, props?: Props<S>) {\n  const editor = area.parentScope<NodeEditor<S>>(NodeEditor)\n\n  area.addPipe(context => {\n    if (!context || typeof context !== 'object' || !('type' in context)) return context\n    if (context.type === 'render' && context.data.type === 'node') {\n      const id = context.data.payload.id\n      const currentNode = editor.getNode(id)\n      const geometry = props?.customize ? props.customize(currentNode) : createClassicNodeGeometry(currentNode)\n\n      area.area.content.updateGeometry(context.data.element, geometry)\n    }\n    return context\n  })\n}\n", "import { ConnectionId, Root, Scope, ScopeAsParameter } from 'rete'\nimport { RenderSignal } from 'rete-area-plugin'\nimport { CircleGeometry } from 'three'\nimport { mergeGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js'\n\nimport { Area3DPlugin } from '../..'\nimport { ExpectSchemes, Position } from '../../types'\n\nexport type Pin = {\n  id: string\n  position: Position\n  selected?: boolean\n}\nexport type PinData = {\n  id: ConnectionId\n  pins: Pin[]\n}\n\ntype Requires =\n  | RenderSignal<'reroute-pins', { data: PinData }>\n\n/**\n * Form generator for embedding rete-connection-reroute-plugin into 3D scene.\n * @param scope Area3DPlugin instance\n */\nexport function reroute<S extends ExpectSchemes, K>(scope: ScopeAsParameter<Scope<K, [Root<S>]>, [Requires]>) {\n  if (!(scope instanceof Area3DPlugin<S, Requires>)) throw new Error('')\n  const area = scope as Area3DPlugin<S, Requires>\n\n  area.addPipe(context => {\n    if (!context || typeof context !== 'object' || !('type' in context)) return context\n    if (context.type === 'render' && context.data.type === 'reroute-pins') {\n      const pinGeometry = new CircleGeometry(10, 16)\n      const pins = context.data.data.pins.map(pin => {\n        return pinGeometry.clone().translate(pin.position.x, pin.position.y, 0)\n      })\n\n      // eslint-disable-next-line no-undefined\n      area.area.content.updateGeometry(context.data.element, pins.length ? mergeGeometries(pins) : undefined)\n    }\n    return context\n  })\n}\n", "/**\n * Group of functions to replicate forms.\n * This extension provides a functions for generating geometry that replicates the form of HTML elements embedded in the scene.\n * @module Extensions/Forms\n */\nexport { comment } from './comment'\nexport type { Props as ConnectionForm } from './connection'\nexport { connection, createClassicConnectionGeometry } from './connection'\nexport type { Props as NodeForm } from './node'\nexport { createClassicNodeGeometry, node } from './node'\nexport type { Params as ClassicNodeOptions } from './node/geometry'\nexport { reroute } from './reroute'\n", "import { Position, Size } from '../types'\n\n/**\n * Bounding box\n */\nconst min = (arr: number[]) => arr.length === 0 ? 0 : Math.min(...arr)\nconst max = (arr: number[]) => arr.length === 0 ? 0 : Math.max(...arr)\n\nexport function getBoundingBox(rects: ({ position: Position } & Size)[]) {\n  const left = min(rects.map(rect => rect.position.x))\n  const top = min(rects.map(rect => rect.position.y))\n  const right = max(rects.map(rect => rect.position.x + rect.width))\n  const bottom = max(rects.map(rect => rect.position.y + rect.height))\n\n  return {\n    left,\n    right,\n    top,\n    bottom,\n    width: Math.abs(left - right),\n    height: Math.abs(top - bottom),\n    center: {\n      x: (left + right) / 2,\n      y: (top + bottom) / 2\n    }\n  }\n}\n", "import { NodeId } from 'rete'\n\nimport { NodeView } from '../node-view'\nimport { ExpectSchemes } from '../types'\n\nexport function getNodesRect<S extends ExpectSchemes>(nodes: S['Node'][], views: Map<NodeId, NodeView>) {\n  return nodes\n    .map(node => ({ view: views.get(node.id) as NodeView, node }))\n    .filter(item => item.view)\n    .map(({ view, node }) => {\n      const { width, height } = node\n\n      if (typeof width !== 'undefined' && typeof height !== 'undefined') {\n        return {\n          position: view.position,\n          width,\n          height\n        }\n      }\n\n      return {\n        position: view.position,\n        width: view.element.clientWidth,\n        height: view.element.clientHeight\n      }\n    })\n}\n", "import { BaseSchemes, NodeEditor } from 'rete'\n\nimport { Area3DPlugin } from '..'\nimport { ExpectSchemes } from '../types'\nimport { getBoundingBox as getBBox } from '../utils/bounding-box'\nimport { getNodesRect } from '../utils/rects'\n\nexport type NodeRef<Schemes extends BaseSchemes> = Schemes['Node'] | Schemes['Node']['id']\n\nexport function getBoundingBox<Schemes extends ExpectSchemes, K>(plugin: Area3DPlugin<Schemes, K>, nodes: NodeRef<Schemes>[]) {\n  const editor = plugin.parentScope<NodeEditor<Schemes>>(NodeEditor)\n  const list = nodes.map(node => typeof node === 'object' ? node : editor.getNode(node))\n  const rects = getNodesRect(list, plugin.nodeViews)\n\n  return getBBox(rects)\n}\n", "import { PerspectiveCamera, Vector3 } from 'three'\n\nimport { Area3DPlugin } from '..'\nimport { ExpectSchemes } from '../types'\nimport { getBoundingBox } from './bounding-box'\n\n/**\n * Parameters for `zoomAt` extension\n */\nexport type Params = {\n  /** Set gap between nodes and the viewport border */\n  scale?: number\n}\n\n/**\n * Move the camera to look at the given nodes\n * @param area The 3D area plugin\n * @param nodes The nodes to look at\n * @param params The lookAt parameters\n * @example Area3DExtensions.lookAt(area, [node1, node2])\n * @example Area3DExtensions.lookAt(area, [node1, node2], { scale: 0.8 })\n */\nexport function lookAt<S extends ExpectSchemes, K>(area: Area3DPlugin<S, K>, nodes: S['Node'][], params?: Params) {\n  const { scale = 0.9 } = params || {}\n  const { scene } = area.area\n  const { camera, orbit, canvases } = scene\n  const canvas = canvases.get(area)\n  const bbox = getBoundingBox(area, nodes)\n\n  if (!canvas) throw new Error('cannot found canvas')\n\n  const distance = getTargetDistance(camera, area.container, bbox, scale)\n  const target = new Vector3(bbox.center.x, bbox.center.y, 0)\n  const source = target.clone().add(new Vector3(0, 0, distance))\n\n  canvas.localToWorld(target)\n  canvas.localToWorld(source)\n\n  camera.position.copy(source)\n  orbit.target.copy(target)\n  orbit.update()\n}\n\nfunction getTargetDistance(camera: PerspectiveCamera, container: HTMLElement, size: { width: number, height: number }, scale: number) {\n  const fov = camera.fov * (Math.PI / 180)\n  const fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect)\n  const dx = Math.abs(size.width / 2 / Math.tan(fovh / 2))\n  const dy = Math.abs(size.height / 2 / Math.tan(fov / 2))\n  const minDistance = Math.abs(container.clientHeight / 2 / Math.tan(fov / 2))\n  const distance = Math.max(dx, dy, minDistance)\n\n  return distance / scale\n}\n", "/**\n * Area 3D extensions.\n * These extensions are specific to the 3D area and provide additional functionality, while many of rete-area-plugin's extensions are also available for this plugin.\n * @priority 7\n * @module Extensions\n */\n\nexport { animate } from './animate'\nexport * as forms from './forms'\nexport type { Params as LookAt } from './lookAt'\nexport { lookAt } from './lookAt'\n", "import { ConnectionId, NodeId, Root, Scope } from 'rete'\nimport { BaseArea, BaseAreaPlugin } from 'rete-area-plugin'\n\nimport { Area, TransformEventParams } from './area'\nimport { ConnectionView } from './connection-view'\nimport { ElementsHolder } from './elements-holder'\nimport { NodeView } from './node-view'\nimport { ExpectSchemes, GetRenderTypes, Position } from './types'\n\nexport type { Area } from './area'\nexport * as Area3DExtensions from './extensions'\nexport type { HybridScene } from './scene'\nexport type { HybridRenderer } from './scene/HybridRenderer'\n\nexport type RenderMeta = { filled?: boolean }\n\n/**\n * Signal types produced by Area3DPlugin instance\n * @priority 10\n */\nexport type Area3D<Schemes extends ExpectSchemes> =\n  | BaseArea<Schemes>\n  | { type: 'transform', data: TransformEventParams }\n  | { type: 'transformed', data: TransformEventParams }\n  | { type: 'resized', data: { event: Event } }\n\nexport type Area3DInherited<Schemes extends ExpectSchemes, ExtraSignals = never> = [Area3D<Schemes> | ExtraSignals, Root<Schemes>]\n\n/**\n * Plugin for embedding node editor into 3D scene.\n * @priority 9\n */\nexport class Area3DPlugin<Schemes extends ExpectSchemes, ExtraSignals = never> extends BaseAreaPlugin<Schemes, Area3D<Schemes> | ExtraSignals> {\n  /**\n   * Area instance, contains nodes, connections and other elements\n   */\n  public area: Area<Area3DPlugin<Schemes, ExtraSignals>>\n  public nodeViews = new Map<NodeId, NodeView>()\n  public connectionViews = new Map<ConnectionId, ConnectionView>()\n  public elements = new ElementsHolder<HTMLElement, Extract<Area3D<Schemes>, { type: 'render' }>['data'] & RenderMeta>()\n  public container: HTMLElement\n\n  /**\n   * @param container HTML element to render area in\n   */\n  constructor(container: HTMLElement)\n  constructor(shared: Area3DPlugin<Schemes, ExtraSignals>)\n  constructor(argument: HTMLElement | Area3DPlugin<Schemes, ExtraSignals>) {\n    super('area-3d')\n    this.container = argument instanceof Area3DPlugin ? argument.container : argument\n    this.container.style.overflow = 'hidden'\n    this.container.addEventListener('contextmenu', this.onContextMenu)\n\n    this.area = new Area(\n      this.container,\n      argument instanceof Area3DPlugin ? argument.area.scene : null,\n      this,\n      {\n        pointerDown: (position, event) => this.emit({ type: 'pointerdown', data: { position, event } }),\n        pointerMove: (position, event) => this.emit({ type: 'pointermove', data: { position, event } }),\n        pointerUp: (position, event) => this.emit({ type: 'pointerup', data: { position, event } }),\n        resize: event => this.emit({ type: 'resized', data: { event } }),\n        transformed: params => this.emit({ type: 'transformed', data: params }),\n        reordered: element => this.emit({ type: 'reordered', data: { element } })\n      },\n      {\n        transform: params => this.emit({ type: 'transform', data: params })\n      }\n    )\n    this.area.scene.addCanvasFor(this)\n  }\n\n  /**\n   * Share the 3D scene with multiple instances of Area3DPlugin\n   * @returns new instance of Area3DPlugin\n   */\n  share() {\n    return new Area3DPlugin<Schemes, ExtraSignals>(this)\n  }\n\n  setParent(scope: Scope<Root<Schemes>, []>) {\n    super.setParent(scope)\n\n    this.addPipe(context => {\n      if (!context || !(typeof context === 'object' && 'type' in context)) return context\n      if (context.type === 'nodecreated') {\n        this.addNodeView(context.data)\n      }\n      if (context.type === 'noderemoved') {\n        this.removeNodeView(context.data.id)\n      }\n      if (context.type === 'connectioncreated') {\n        this.addConnectionView(context.data)\n      }\n      if (context.type === 'connectionremoved') {\n        this.removeConnectionView(context.data.id)\n      }\n      if (context.type === 'render') {\n        this.elements.set(context.data)\n      }\n      if (context.type === 'unmount') {\n        this.elements.delete(context.data.element)\n      }\n      return context\n    })\n  }\n\n  private onContextMenu = (event: MouseEvent) => {\n    this.emit({ type: 'contextmenu', data: { event, context: 'root' } })\n  }\n\n  public addNodeView(node: Schemes['Node']) {\n    const { id } = node\n    const view = new NodeView(\n      {\n        picked: () => this.emit({ type: 'nodepicked', data: { id } }),\n        translated: data => this.emit({ type: 'nodetranslated', data: { id, ...data } }),\n        dragged: () => this.emit({ type: 'nodedragged', data: node }),\n        contextmenu: event => this.emit({ type: 'contextmenu', data: { event, context: node } }),\n        resized: ({ size }) => this.emit({ type: 'noderesized', data: { id: node.id, size } })\n      },\n      {\n        translate: data => this.emit({ type: 'nodetranslate', data: { id, ...data } }),\n        resize: ({ size }) => this.emit({ type: 'noderesize', data: { id: node.id, size } })\n      }\n    )\n\n    this.nodeViews.set(id, view)\n    this.area.content.add(view.element, view.object)\n\n    this.emit({\n      type: 'render',\n      data: { element: view.element, type: 'node', payload: node }\n    })\n\n    return view\n  }\n\n  public removeNodeView(id: NodeId) {\n    const view = this.nodeViews.get(id)\n\n    if (view) {\n      this.emit({ type: 'unmount', data: { element: view.element } })\n      this.nodeViews.delete(id)\n      this.area.content.remove(view.element)\n    }\n  }\n\n  public addConnectionView(connection: Schemes['Connection']) {\n    const view = new ConnectionView({\n      contextmenu: event => this.emit({ type: 'contextmenu', data: { event, context: connection } })\n    })\n\n    this.connectionViews.set(connection.id, view)\n    this.area.content.add(view.element, view.object)\n\n    this.emit({\n      type: 'render',\n      data: { element: view.element, type: 'connection', payload: connection }\n    })\n\n    return view\n  }\n\n  public removeConnectionView(id: ConnectionId) {\n    const view = this.connectionViews.get(id)\n\n    if (view) {\n      this.emit({ type: 'unmount', data: { element: view.element } })\n      this.connectionViews.delete(id)\n      this.area.content.remove(view.element)\n    }\n  }\n\n  /**\n   * Translate node to position\n   * @param id Node id\n   * @param position Position\n   */\n  public async translate(id: NodeId, { x, y }: Position) {\n    const view = this.nodeViews.get(id)\n\n    if (view) return await view.translate(x, y)\n  }\n\n  /**\n   * Resize node\n   * @param id Node id\n   * @param width Desired width\n   * @param height Desired height\n   */\n  public async resize(id: NodeId, width: number, height: number) {\n    const view = this.nodeViews.get(id)\n\n    if (view) return await view.resize(width, height)\n  }\n\n  /**\n   * Force update rendered element by id (node, connection, etc.)\n   * @param type Element type\n   * @param id Element id\n   * @emits render\n   */\n  public async update(type: GetRenderTypes<Area3D<Schemes>> | GetRenderTypes<ExtraSignals>, id: string) {\n    const data = this.elements.get(type, id)\n\n    if (data) await this.emit({ type: 'render', data } as Area3D<Schemes>)\n  }\n\n  /**\n   * Destroy all views and remove all event listeners\n   */\n  destroy() {\n    this.container.removeEventListener('contextmenu', this.onContextMenu)\n    Array.from(this.connectionViews.keys()).forEach(id => this.removeConnectionView(id))\n    Array.from(this.nodeViews.keys()).forEach(id => this.removeNodeView(id))\n    this.area.destroy()\n  }\n}\n"],
  "mappings": "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",
  "names": ["flipFaces", "geometry", "index", "getIndex", "numTriangles", "count", "i", "a", "getX", "b", "c", "setXYZ", "createMaterial", "transparent", "ShadowMaterial", "opacity", "blending", "NoBlending", "side", "FrontSide", "createBackMaterial", "MeshBasicMaterial", "color", "BackSide", "ObjectHTML", "_Object3D", "_inherits", "_super", "_createSuper", "element", "_this", "_classCallCheck", "call", "css3dObject", "CSS3DObject", "onAfterRender", "internalTranslate", "style", "transform", "endsWith", "add", "front", "Mesh", "back", "castShadow", "updateMaterials", "_createClass", "key", "value", "updateGeometry", "scaled", "clone", "scale", "BufferGeometry", "materials", "material", "Object3D", "findTop", "objects", "sort", "position", "compareDocumentPosition", "Node", "DOCUMENT_POSITION_FOLLOWING", "DOCUMENT_POSITION_PRECEDING", "Content", "scene", "scope", "reordered", "_scene$renderer$css3d", "_defineProperty", "WeakMap", "css3dContainer", "renderer", "css3d", "domElement", "firstElementChild", "HTMLElement", "Error", "holder", "getPointerFrom", "event", "_this$holder$getBound", "getBoundingClientRect", "left", "top", "x", "clientX", "y", "clientY", "object", "arguments", "length", "undefined", "set", "appendChild", "_reorder", "_asyncToGenerator", "_regeneratorRuntime", "mark", "_callee", "target", "next", "wrap", "_callee$", "_context", "prev", "contains", "insertBefore", "stop", "reorder", "_x", "_x2", "apply", "remove", "get", "raycaster", "Raycaster", "DragControls", "_EventDispatcher", "camera", "getPlane", "_assertThisInitialized", "Set", "Vector2", "Vector3", "Matrix4", "enabled", "updatePointer", "setFromCamera", "pointer", "selected", "ray", "intersectPlane", "intersection", "newPosition", "sub", "offset", "applyMatrix4", "inverseMatrix", "eventData", "type", "dispatchEvent", "intersections", "intersectObjects", "getObjects", "findIntersectedObject", "parent", "copy", "matrixWorld", "invert", "worldPosition", "setFromMatrixPosition", "stopPropagation", "cursor", "hovered", "rect", "width", "height", "touchAction", "activate", "attach", "detach", "addEventListener", "onPointerMove", "onPointerDown", "onPointerCancel", "deactivate", "removeEventListener", "dispose", "Array", "from", "values", "getRaycaster", "findContainer", "traverseAncestors", "intersectedObject", "includes", "_this2", "map", "EventDispatcher", "DraggableObject3D", "_ObjectHTML", "events", "attachDraggableHooks", "controls", "e", "start", "_event$position", "z", "translate", "drag", "HybridRenderer", "getDefaultCSS3DRenderer", "webgl", "getDefaultWebGLRenderer", "document", "createElement", "setAttribute", "fillAbsolute", "pointerEvents", "getContent", "CSS3DRenderer", "WebGLRenderer", "alpha", "antialias", "setPixelRatio", "window", "devicePixelRatio", "setClearColor", "shadowMap", "PCFSoftShadowMap", "setSize", "render", "el", "min", "max", "panLeft", "panUp", "pan", "orbitControlsRestrictor", "orbit", "check", "updated", "previous", "previousTarget", "rotation", "_previous", "p", "r", "t", "sent", "fromArray", "update", "HybridScene", "container", "Scene", "Map", "PerspectiveCamera", "fov", "near", "far", "createOrbitControls", "createDragControls", "OrbitControls", "orbitChangeNumber", "canvas", "canvases", "canvasToPlane", "plane", "Plane", "normal", "applyQuaternion", "quaternion", "setFromNormalAndCoplanarPoint", "addCanvasFor", "root", "resize", "aspect", "updateProjectionMatrix", "getCanvasFor", "worldToLocal", "Area", "guards", "setPointerFrom", "pointerDown", "pointerMove", "pointerUp", "clientWidth", "clientHeight", "content", "pointerdown", "pointermove", "pointerup", "current", "transformed", "getCanvas", "point", "destroy", "ConnectionView", "contextmenu", "ElementsHolder", "context", "payload", "id", "views", "viewsElements", "concat", "_delete", "_view$payload", "view", "NodeView", "_ref", "translation", "_objectSpread", "abrupt", "data", "translated", "_ref2", "_callee2", "size", "_callee2$", "_context2", "children", "item", "resized", "_x3", "_x4", "picked", "dragged", "animate", "area", "tick", "time", "requestAnimationFrame", "performance", "now", "getRoundedShape", "radius", "shape", "Shape", "moveTo", "lineTo", "quadraticCurveTo", "closePath", "comment", "commentScope", "parentScope", "Area3DPlugin", "addPipe", "updateCommentGeometry", "comments", "commentGeometry", "ShapeGeometry", "__commentGeometry", "existing", "meta", "require$$0", "vec2Copy", "require$$1", "require$$2", "require$$3", "segment", "createClassicConnectionGeometry", "path", "segments", "contours", "parse", "points", "_slicedToArray", "flat", "PlaneGeometry", "prevPoint", "nextPoint", "vectorBetweenPoints", "normalBetweenPoints", "normalize", "multiplyScalar", "attributes", "setX", "setY", "connection", "props", "renderScope", "_typeof", "connectionViews", "classicConnectionPath", "customize", "createClassicNodeGeometry", "params", "_ref$borderRadius", "borderRadius", "_ref$inputsOffset", "inputsOffset", "_ref$outputsOffset", "outputsOffset", "_ref$socketRadius", "socketRadius", "_ref$socketMargin", "socketMargin", "fixWidth", "fixHeight", "circle", "CircleGeometry", "extra", "inputs", "Object", "entries", "geom", "push", "outputs", "mergeGeometries", "node", "editor", "NodeEditor", "currentNode", "getNode", "reroute", "pinGeometry", "pins", "pin", "arr", "Math", "_toConsumableArray", "getBoundingBox", "rects", "right", "bottom", "abs", "center", "getNodesRect", "nodes", "filter", "plugin", "list", "nodeViews", "getBBox", "lookAt", "_ref$scale", "bbox", "distance", "getTargetDistance", "source", "localToWorld", "PI", "fovh", "atan", "tan", "dx", "dy", "minDistance", "_BaseAreaPlugin", "argument", "emit", "overflow", "onContextMenu", "share", "setParent", "_get", "_getPrototypeOf", "prototype", "addNodeView", "removeNodeView", "addConnectionView", "removeConnectionView", "elements", "_this3", "_this4", "_translate", "_ref3", "_resize", "_x5", "_update", "_callee3", "_callee3$", "_context3", "_x6", "_x7", "_this5", "keys", "forEach", "BaseAreaPlugin"]
}
