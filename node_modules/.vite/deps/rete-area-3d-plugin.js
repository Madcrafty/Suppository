import {
  classicConnectionPath
} from "./chunk-FVGAXGAB.js";
import {
  _slicedToArray
} from "./chunk-W4ORNLAH.js";
import {
  BaseAreaPlugin
} from "./chunk-V5YHK5D6.js";
import {
  _get
} from "./chunk-KLWA5HFX.js";
import {
  _toConsumableArray
} from "./chunk-KYEYYJ4D.js";
import {
  BackSide,
  BufferAttribute,
  BufferGeometry,
  CircleGeometry,
  EventDispatcher,
  FrontSide,
  MOUSE,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  NoBlending,
  Object3D,
  PCFSoftShadowMap,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShadowMaterial,
  Shape,
  ShapeGeometry,
  Spherical,
  TOUCH,
  Vector2,
  Vector3,
  WebGLRenderer
} from "./chunk-BQYUDMOM.js";
import {
  NodeEditor,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _typeof,
  require_regenerator
} from "./chunk-64XSJ2AG.js";
import {
  __toESM
} from "./chunk-GFT2G5UO.js";

// node_modules/rete-area-3d-plugin/area3-d-plugin.esm.js
var import_regenerator = __toESM(require_regenerator());
var _position = new Vector3();
var _quaternion = new Quaternion();
var _scale = new Vector3();
var CSS3DObject = class extends Object3D {
  constructor(element = document.createElement("div")) {
    super();
    this.isCSS3DObject = true;
    this.element = element;
    this.element.style.position = "absolute";
    this.element.style.pointerEvents = "auto";
    this.element.style.userSelect = "none";
    this.element.setAttribute("draggable", false);
    this.addEventListener("removed", function() {
      this.traverse(function(object) {
        if (object.element instanceof Element && object.element.parentNode !== null) {
          object.element.parentNode.removeChild(object.element);
        }
      });
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
};
var _matrix = new Matrix4();
var _matrix2 = new Matrix4();
var CSS3DRenderer = class {
  constructor(parameters = {}) {
    const _this = this;
    let _width, _height;
    let _widthHalf, _heightHalf;
    const cache = {
      camera: { fov: 0, style: "" },
      objects: /* @__PURE__ */ new WeakMap()
    };
    const domElement = parameters.element !== void 0 ? parameters.element : document.createElement("div");
    domElement.style.overflow = "hidden";
    this.domElement = domElement;
    const viewElement = document.createElement("div");
    viewElement.style.transformOrigin = "0 0";
    viewElement.style.pointerEvents = "none";
    domElement.appendChild(viewElement);
    const cameraElement = document.createElement("div");
    cameraElement.style.transformStyle = "preserve-3d";
    viewElement.appendChild(cameraElement);
    this.getSize = function() {
      return {
        width: _width,
        height: _height
      };
    };
    this.render = function(scene, camera) {
      const fov = camera.projectionMatrix.elements[5] * _heightHalf;
      if (cache.camera.fov !== fov) {
        viewElement.style.perspective = camera.isPerspectiveCamera ? fov + "px" : "";
        cache.camera.fov = fov;
      }
      if (camera.view && camera.view.enabled) {
        viewElement.style.transform = `translate( ${-camera.view.offsetX * (_width / camera.view.width)}px, ${-camera.view.offsetY * (_height / camera.view.height)}px )`;
        viewElement.style.transform += `scale( ${camera.view.fullWidth / camera.view.width}, ${camera.view.fullHeight / camera.view.height} )`;
      } else {
        viewElement.style.transform = "";
      }
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      let tx, ty;
      if (camera.isOrthographicCamera) {
        tx = -(camera.right + camera.left) / 2;
        ty = (camera.top + camera.bottom) / 2;
      }
      const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
      const cameraCSSMatrix = camera.isOrthographicCamera ? `scale( ${scaleByViewOffset} )scale(` + fov + ")translate(" + epsilon(tx) + "px," + epsilon(ty) + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse) : `scale( ${scaleByViewOffset} )translateZ(` + fov + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
      const style = cameraCSSMatrix + "translate(" + _widthHalf + "px," + _heightHalf + "px)";
      if (cache.camera.style !== style) {
        cameraElement.style.transform = style;
        cache.camera.style = style;
      }
      renderObject(scene, scene, camera);
    };
    this.setSize = function(width, height) {
      _width = width;
      _height = height;
      _widthHalf = _width / 2;
      _heightHalf = _height / 2;
      domElement.style.width = width + "px";
      domElement.style.height = height + "px";
      viewElement.style.width = width + "px";
      viewElement.style.height = height + "px";
      cameraElement.style.width = width + "px";
      cameraElement.style.height = height + "px";
    };
    function epsilon(value) {
      return Math.abs(value) < 1e-10 ? 0 : value;
    }
    function getCameraCSSMatrix(matrix) {
      const elements = matrix.elements;
      return "matrix3d(" + epsilon(elements[0]) + "," + epsilon(-elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(elements[6]) + "," + epsilon(elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(-elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(-elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
    }
    function getObjectCSSMatrix(matrix) {
      const elements = matrix.elements;
      const matrix3d = "matrix3d(" + epsilon(elements[0]) + "," + epsilon(elements[1]) + "," + epsilon(elements[2]) + "," + epsilon(elements[3]) + "," + epsilon(-elements[4]) + "," + epsilon(-elements[5]) + "," + epsilon(-elements[6]) + "," + epsilon(-elements[7]) + "," + epsilon(elements[8]) + "," + epsilon(elements[9]) + "," + epsilon(elements[10]) + "," + epsilon(elements[11]) + "," + epsilon(elements[12]) + "," + epsilon(elements[13]) + "," + epsilon(elements[14]) + "," + epsilon(elements[15]) + ")";
      return "translate(-50%,-50%)" + matrix3d;
    }
    function renderObject(object, scene, camera, cameraCSSMatrix) {
      if (object.isCSS3DObject) {
        const visible = object.visible === true && object.layers.test(camera.layers) === true;
        object.element.style.display = visible === true ? "" : "none";
        if (visible === true) {
          object.onBeforeRender(_this, scene, camera);
          let style;
          if (object.isCSS3DSprite) {
            _matrix.copy(camera.matrixWorldInverse);
            _matrix.transpose();
            if (object.rotation2D !== 0)
              _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));
            object.matrixWorld.decompose(_position, _quaternion, _scale);
            _matrix.setPosition(_position);
            _matrix.scale(_scale);
            _matrix.elements[3] = 0;
            _matrix.elements[7] = 0;
            _matrix.elements[11] = 0;
            _matrix.elements[15] = 1;
            style = getObjectCSSMatrix(_matrix);
          } else {
            style = getObjectCSSMatrix(object.matrixWorld);
          }
          const element = object.element;
          const cachedObject = cache.objects.get(object);
          if (cachedObject === void 0 || cachedObject.style !== style) {
            element.style.transform = style;
            const objectData = { style };
            cache.objects.set(object, objectData);
          }
          if (element.parentNode !== cameraElement) {
            cameraElement.appendChild(element);
          }
          object.onAfterRender(_this, scene, camera);
        }
      }
      for (let i = 0, l = object.children.length; i < l; i++) {
        renderObject(object.children[i], scene, camera);
      }
    }
  }
};
function flipFaces(geometry) {
  var index2 = geometry.getIndex();
  if (index2) {
    var numTriangles = index2.count / 3;
    for (var i = 0; i < numTriangles; i++) {
      var a = index2.getX(i * 3 + 2);
      var b = index2.getX(i * 3 + 1);
      var c = index2.getX(i * 3);
      index2.setXYZ(i * 3, a, b, c);
    }
  }
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function createMaterial(transparent) {
  return new ShadowMaterial({
    transparent: true,
    opacity: transparent ? 0.5 : 0.7,
    blending: NoBlending,
    side: FrontSide
  });
}
function createBackMaterial() {
  return new MeshBasicMaterial({
    color: 7244031,
    side: BackSide
  });
}
var ObjectHTML = function(_Object3D) {
  _inherits(ObjectHTML2, _Object3D);
  var _super = _createSuper$3(ObjectHTML2);
  function ObjectHTML2(element) {
    var _this;
    _classCallCheck(this, ObjectHTML2);
    _this = _super.call(this);
    _this.css3dObject = new CSS3DObject(element);
    _this.css3dObject.onAfterRender = function() {
      var internalTranslate = " translate(50%, 50%)";
      if (!element.style.transform.endsWith(internalTranslate)) {
        element.style.transform += internalTranslate;
      }
    };
    _this.add(_this.css3dObject);
    var front = new Mesh();
    _this.front = front;
    _this.add(front);
    var back = new Mesh();
    back.castShadow = true;
    _this.back = back;
    _this.add(back);
    _this.updateMaterials();
    return _this;
  }
  _createClass(ObjectHTML2, [{
    key: "updateGeometry",
    value: function updateGeometry(geometry) {
      var scaled = geometry === null || geometry === void 0 ? void 0 : geometry.clone().scale(1, -1, 1);
      if (scaled)
        flipFaces(scaled);
      if (this.front)
        this.front.geometry = scaled || new BufferGeometry();
      if (this.back)
        this.back.geometry = scaled || new BufferGeometry();
    }
  }, {
    key: "updateMaterials",
    value: function updateMaterials(materials) {
      if (this.front)
        this.front.material = (materials === null || materials === void 0 ? void 0 : materials.front) || createMaterial(false);
      if (this.back)
        this.back.material = (materials === null || materials === void 0 ? void 0 : materials.back) || createBackMaterial();
    }
  }]);
  return ObjectHTML2;
}(Object3D);
function findTop(objects) {
  objects.sort(function(a, b) {
    if (!a.css3dObject || !b.css3dObject)
      return 0;
    var position = a.css3dObject.element.compareDocumentPosition(b.css3dObject.element);
    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      return -1;
    }
    return 0;
  });
  return objects[0];
}
var Content = function() {
  function Content2(scene, scope, reordered) {
    var _scene$renderer$css3d;
    _classCallCheck(this, Content2);
    _defineProperty(this, "objects", /* @__PURE__ */ new WeakMap());
    this.scene = scene;
    this.scope = scope;
    this.reordered = reordered;
    var css3dContainer = (_scene$renderer$css3d = scene.renderer.css3d.domElement.firstElementChild) === null || _scene$renderer$css3d === void 0 ? void 0 : _scene$renderer$css3d.firstElementChild;
    if (!css3dContainer || !(css3dContainer instanceof HTMLElement)) {
      throw new Error("cannot find container for css3d element");
    }
    this.holder = css3dContainer;
  }
  _createClass(Content2, [{
    key: "getPointerFrom",
    value: function getPointerFrom(event) {
      var _this$holder$getBound = this.holder.getBoundingClientRect(), left = _this$holder$getBound.left, top = _this$holder$getBound.top;
      var x = event.clientX - left;
      var y = event.clientY - top;
      return {
        x,
        y
      };
    }
    /**
     * Add an HTML element to the 3D scene
     * @param element HTML element
     */
  }, {
    key: "add",
    value: function add(element) {
      var object = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new ObjectHTML(element);
      this.objects.set(element, object);
      this.holder.appendChild(element);
      this.scene.add(object, this.scope);
    }
    /**
     * Reorder the given element in the 3D scene
     * @param target HTML element to reorder
     * @param next HTML element to insert before
     * @throws if `target` or `next` are not in the scene
     */
    // eslint-disable-next-line no-undef
  }, {
    key: "reorder",
    value: function() {
      var _reorder = _asyncToGenerator(import_regenerator.default.mark(function _callee(target, next) {
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (this.holder.contains(target)) {
                  _context.next = 2;
                  break;
                }
                throw new Error("content doesn't have 'target' for reordering");
              case 2:
                if (!(next !== null && !this.holder.contains(next))) {
                  _context.next = 4;
                  break;
                }
                throw new Error("content doesn't have 'next' for reordering");
              case 4:
                this.holder.insertBefore(target, next);
                _context.next = 7;
                return this.reordered(target);
              case 7:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function reorder(_x, _x2) {
        return _reorder.apply(this, arguments);
      }
      return reorder;
    }()
    /**
     * Remove an HTML element from the 3D scene
     * @param element HTML element
     */
  }, {
    key: "remove",
    value: function remove(element) {
      var object = this.objects.get(element);
      if (object) {
        this.objects["delete"](element);
        this.scene.remove(object, this.scope);
      }
    }
    /**
     * Update the form (geometry) of the given element
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(element, geometry) {
      var object = this.objects.get(element);
      if (object) {
        object.updateGeometry(typeof geometry === "function" ? geometry(object.front.geometry) : geometry);
      }
    }
    /**
     * Update the material of the given element
     */
  }, {
    key: "updateMaterials",
    value: function updateMaterials(element, materials) {
      var object = this.objects.get(element);
      if (object)
        object.updateMaterials(materials);
    }
  }]);
  return Content2;
}();
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var raycaster = new Raycaster();
var DragControls = function(_EventDispatcher) {
  _inherits(DragControls2, _EventDispatcher);
  var _super = _createSuper$2(DragControls2);
  function DragControls2(camera, domElement, getPlane) {
    var _this;
    _classCallCheck(this, DragControls2);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "enabled", true);
    _defineProperty(_assertThisInitialized(_this), "intersections", []);
    _defineProperty(_assertThisInitialized(_this), "selected", null);
    _defineProperty(_assertThisInitialized(_this), "hovered", null);
    _defineProperty(_assertThisInitialized(_this), "objects", /* @__PURE__ */ new Set());
    _defineProperty(_assertThisInitialized(_this), "pointer", new Vector2());
    _defineProperty(_assertThisInitialized(_this), "offset", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "intersection", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "worldPosition", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "inverseMatrix", new Matrix4());
    _defineProperty(_assertThisInitialized(_this), "onPointerMove", function(event) {
      if (_this.enabled === false)
        return;
      _this.updatePointer(event);
      raycaster.setFromCamera(_this.pointer, _this.camera);
      if (_this.selected) {
        if (raycaster.ray.intersectPlane(_this.getPlane(_this.selected), _this.intersection)) {
          var newPosition = _this.intersection.sub(_this.offset).applyMatrix4(_this.inverseMatrix);
          var eventData = {
            type: "drag",
            object: _this.selected,
            position: newPosition
          };
          _this.dispatchEvent(eventData);
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onPointerDown", function(event) {
      if (_this.enabled === false)
        return;
      _this.updatePointer(event);
      _this.intersections.length = 0;
      raycaster.setFromCamera(_this.pointer, _this.camera);
      _this.intersections = raycaster.intersectObjects(_this.getObjects(), true);
      if (_this.intersections.length > 0) {
        _this.selected = _this.findIntersectedObject(_this.intersections) || null;
        if (!_this.selected)
          return;
        if (!_this.selected.parent)
          throw new Error("parent required for selected object");
        if (raycaster.ray.intersectPlane(_this.getPlane(_this.selected), _this.intersection)) {
          _this.inverseMatrix.copy(_this.selected.parent.matrixWorld).invert();
          _this.offset.copy(_this.intersection).sub(_this.worldPosition.setFromMatrixPosition(_this.selected.matrixWorld));
        }
        event.stopPropagation();
        _this.domElement.style.cursor = "move";
        var eventData = {
          type: "dragstart",
          object: _this.selected
        };
        _this.dispatchEvent(eventData);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onPointerCancel", function() {
      if (_this.enabled === false)
        return;
      if (_this.selected) {
        var eventData = {
          type: "dragend",
          object: _this.selected
        };
        _this.dispatchEvent(eventData);
        _this.selected = null;
      }
      _this.domElement.style.cursor = _this.hovered ? "pointer" : "auto";
    });
    _defineProperty(_assertThisInitialized(_this), "updatePointer", function(event) {
      var rect = _this.domElement.getBoundingClientRect();
      _this.pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
      _this.pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
    });
    _this.camera = camera;
    _this.domElement = domElement;
    _this.getPlane = getPlane;
    _this.domElement.style.touchAction = "none";
    _this.activate();
    return _this;
  }
  _createClass(DragControls2, [{
    key: "attach",
    value: function attach(object) {
      this.objects.add(object);
    }
  }, {
    key: "detach",
    value: function detach(object) {
      this.objects["delete"](object);
    }
  }, {
    key: "activate",
    value: function activate() {
      this.domElement.addEventListener("pointermove", this.onPointerMove);
      this.domElement.addEventListener("pointerdown", this.onPointerDown);
      this.domElement.addEventListener("pointerup", this.onPointerCancel);
      this.domElement.addEventListener("pointerleave", this.onPointerCancel);
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.domElement.removeEventListener("pointermove", this.onPointerMove);
      this.domElement.removeEventListener("pointerdown", this.onPointerDown);
      this.domElement.removeEventListener("pointerup", this.onPointerCancel);
      this.domElement.removeEventListener("pointerleave", this.onPointerCancel);
      this.domElement.style.cursor = "";
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.deactivate();
    }
  }, {
    key: "getObjects",
    value: function getObjects() {
      return Array.from(this.objects.values());
    }
  }, {
    key: "getRaycaster",
    value: function getRaycaster() {
      return raycaster;
    }
  }, {
    key: "findContainer",
    value: function findContainer(intersection) {
      var object = null;
      var objects = this.getObjects();
      intersection.object.traverseAncestors(function(intersectedObject) {
        if (objects.includes(intersectedObject) && intersectedObject instanceof ObjectHTML)
          object = intersectedObject;
      });
      if (!object)
        throw new Error("cannot find Object3D");
      return object;
    }
  }, {
    key: "findIntersectedObject",
    value: function findIntersectedObject(intersections) {
      var _this2 = this;
      return findTop(intersections.map(function(i) {
        return _this2.findContainer(i);
      }));
    }
  }]);
  return DragControls2;
}(EventDispatcher);
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DraggableObject3D = function(_ObjectHTML) {
  _inherits(DraggableObject3D2, _ObjectHTML);
  var _super = _createSuper$1(DraggableObject3D2);
  function DraggableObject3D2(element, events) {
    var _this;
    _classCallCheck(this, DraggableObject3D2);
    _this = _super.call(this, element);
    _this.events = events;
    return _this;
  }
  return _createClass(DraggableObject3D2);
}(ObjectHTML);
function attachDraggableHooks(controls) {
  controls.addEventListener("dragstart", function(e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      event.object.events.start();
    }
  });
  controls.addEventListener("drag", function(e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      var _event$position = event.position, x = _event$position.x, y = _event$position.y, z = _event$position.z;
      event.object.events.translate(x, y, z);
    }
  });
  controls.addEventListener("dragend", function(e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      event.object.events.drag();
    }
  });
}
var HybridRenderer = function() {
  function HybridRenderer2() {
    _classCallCheck(this, HybridRenderer2);
    this.css3d = this.getDefaultCSS3DRenderer();
    this.webgl = this.getDefaultWebGLRenderer();
    this.domElement = document.createElement("div");
    this.css3d.domElement.setAttribute("data-css3d", "true");
    fillAbsolute(this.domElement);
    fillAbsolute(this.css3d.domElement);
    fillAbsolute(this.webgl.domElement);
    this.domElement.appendChild(this.css3d.domElement);
    this.domElement.appendChild(this.webgl.domElement);
    this.webgl.domElement.style.pointerEvents = "none";
  }
  _createClass(HybridRenderer2, [{
    key: "getContent",
    value: function getContent() {
      return this.webgl.domElement.firstElementChild;
    }
  }, {
    key: "getDefaultCSS3DRenderer",
    value: function getDefaultCSS3DRenderer() {
      var css3d = new CSS3DRenderer();
      return css3d;
    }
  }, {
    key: "getDefaultWebGLRenderer",
    value: function getDefaultWebGLRenderer() {
      var webgl = new WebGLRenderer({
        alpha: false,
        antialias: true
      });
      webgl.setPixelRatio(window.devicePixelRatio);
      webgl.setClearColor(16777215, 0);
      webgl.shadowMap.enabled = true;
      webgl.shadowMap.type = PCFSoftShadowMap;
      return webgl;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.css3d.setSize(width, height);
      this.webgl.setSize(width, height);
    }
  }, {
    key: "render",
    value: function render(scene, camera) {
      this.css3d.render(scene, camera);
      this.webgl.render(scene, camera);
    }
  }]);
  return HybridRenderer2;
}();
function fillAbsolute(el) {
  el.style.width = "100%";
  el.style.height = "100%";
  el.style.position = "absolute";
  el.style.left = "0";
  el.style.top = "0";
}
var _changeEvent = { type: "change" };
var _startEvent = { type: "start" };
var _endEvent = { type: "end" };
var _ray = new Ray();
var _plane = new Plane();
var TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
var OrbitControls = class extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      const offset = new Vector3();
      const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3();
      const lastQuaternion = new Quaternion();
      const lastTargetPosition = new Vector3();
      const twoPI = 2 * Math.PI;
      return function update(deltaTime = null) {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle(deltaTime));
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min3 = scope.minAzimuthAngle;
        let max3 = scope.maxAzimuthAngle;
        if (isFinite(min3) && isFinite(max3)) {
          if (min3 < -Math.PI)
            min3 += twoPI;
          else if (min3 > Math.PI)
            min3 -= twoPI;
          if (max3 < -Math.PI)
            max3 += twoPI;
          else if (max3 > Math.PI)
            max3 -= twoPI;
          if (min3 <= max3) {
            spherical.theta = Math.max(min3, Math.min(max3, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min3 + max3) / 2 ? Math.max(min3, spherical.theta) : Math.min(max3, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {
          spherical.radius = clampDistance(spherical.radius);
        } else {
          spherical.radius = clampDistance(spherical.radius * scale);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        let zoomChanged = false;
        if (scope.zoomToCursor && performCursorZoom) {
          let newRadius = null;
          if (scope.object.isPerspectiveCamera) {
            const prevRadius = offset.length();
            newRadius = clampDistance(prevRadius * scale);
            const radiusDelta = prevRadius - newRadius;
            scope.object.position.addScaledVector(dollyDirection, radiusDelta);
            scope.object.updateMatrixWorld();
          } else if (scope.object.isOrthographicCamera) {
            const mouseBefore = new Vector3(mouse.x, mouse.y, 0);
            mouseBefore.unproject(scope.object);
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
            const mouseAfter = new Vector3(mouse.x, mouse.y, 0);
            mouseAfter.unproject(scope.object);
            scope.object.position.sub(mouseAfter).add(mouseBefore);
            scope.object.updateMatrixWorld();
            newRadius = offset.length();
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
            scope.zoomToCursor = false;
          }
          if (newRadius !== null) {
            if (this.screenSpacePanning) {
              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);
            } else {
              _ray.origin.copy(scope.object.position);
              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);
              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {
                object.lookAt(scope.target);
              } else {
                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);
                _ray.intersectPlane(_plane, scope.target);
              }
            }
          }
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        }
        scale = 1;
        performCursorZoom = false;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS || lastTargetPosition.distanceToSquared(scope.target) > 0) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          lastTargetPosition.copy(scope.target);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerUp);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3();
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const dollyDirection = new Vector3();
    const mouse = new Vector2();
    let performCursorZoom = false;
    const pointers = [];
    const pointerPositions = {};
    function getAutoRotationAngle(deltaTime) {
      if (deltaTime !== null) {
        return 2 * Math.PI / 60 * scope.autoRotateSpeed * deltaTime;
      } else {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = function() {
      const v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    const panUp = function() {
      const v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    const pan = function() {
      const offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale /= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera) {
        scale *= dollyScale;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function updateMouseParameters(event) {
      if (!scope.zoomToCursor) {
        return;
      }
      performCursorZoom = true;
      const rect = scope.domElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const w = rect.width;
      const h = rect.height;
      mouse.x = x / w * 2 - 1;
      mouse.y = -(y / h) * 2 + 1;
      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();
    }
    function clampDistance(dist) {
      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      updateMouseParameters(event);
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      updateMouseParameters(event);
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(-2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight);
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY);
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX;
      const dy = pointers[0].pageY - pointers[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enablePan)
        handleTouchStartPan();
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom)
        handleTouchStartDolly();
      if (scope.enableRotate)
        handleTouchStartRotate();
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
      }
      scope.dispatchEvent(_endEvent);
      state = STATE.NONE;
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE)
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(_endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate();
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan();
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan();
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate();
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
      return pointerPositions[pointer.pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerUp);
    scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
    this.update();
  }
};
function orbitControlsRestrictor(orbit, camera, check, updated) {
  var previous;
  var previousTarget;
  orbit.addEventListener("change", _asyncToGenerator(import_regenerator.default.mark(function _callee() {
    var position, rotation, _previous, p, r, t;
    return import_regenerator.default.wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            position = camera.position.clone();
            rotation = camera.rotation.clone();
            _context.next = 4;
            return check({
              position,
              rotation
            }, previous);
          case 4:
            if (!_context.sent) {
              _context.next = 9;
              break;
            }
            previous = {
              position,
              rotation
            };
            previousTarget = orbit.target.clone();
            _context.next = 13;
            break;
          case 9:
            if (previous && previousTarget) {
              _previous = previous, p = _previous.position, r = _previous.rotation;
              t = previousTarget;
              camera.position.fromArray([p.x, p.y, p.z]);
              camera.rotation.fromArray([r.x, r.y, r.z]);
              orbit.target.fromArray([t.x, t.y, t.z]);
            }
            orbit.update();
            _context.next = 13;
            return updated({
              position,
              rotation
            }, previous);
          case 13:
          case "end":
            return _context.stop();
        }
    }, _callee);
  })));
}
var HybridScene = function() {
  function HybridScene2(container) {
    _classCallCheck(this, HybridScene2);
    _defineProperty(this, "root", new Scene());
    _defineProperty(this, "canvases", /* @__PURE__ */ new Map());
    this.container = container;
    this.camera = new PerspectiveCamera();
    this.camera.position.set(0, 0, 1e3);
    this.camera.fov = 45;
    this.camera.near = 1;
    this.camera.far = 4e3;
    this.renderer = new HybridRenderer();
    container.appendChild(this.renderer.domElement);
    this.orbit = this.createOrbitControls();
    this.controls = this.createDragControls(this.orbit);
  }
  _createClass(HybridScene2, [{
    key: "createOrbitControls",
    value: function createOrbitControls() {
      var orbit = new OrbitControls(this.camera, this.renderer.domElement);
      orbit.update();
      var orbitChangeNumber = 0;
      orbit.addEventListener("start", function() {
        orbitChangeNumber = 0;
      });
      orbit.addEventListener("change", function() {
        orbitChangeNumber++;
      });
      this.renderer.domElement.addEventListener("contextmenu", function(e) {
        if (orbitChangeNumber > 5)
          e.stopPropagation();
      });
      return orbit;
    }
  }, {
    key: "createDragControls",
    value: function createDragControls(orbit) {
      var _this = this;
      var controls = new DragControls(this.camera, this.renderer.domElement, function(object) {
        var canvas = object.parent;
        if (!canvas)
          throw new Error("object doesnt have parent");
        if (!Array.from(_this.canvases.values()).includes(canvas))
          throw new Error("object parent isnt canvas");
        return _this.canvasToPlane(canvas);
      });
      attachDraggableHooks(controls);
      controls.addEventListener("dragstart", function() {
        return orbit.enabled = false;
      });
      controls.addEventListener("dragend", function() {
        return orbit.enabled = true;
      });
      return controls;
    }
  }, {
    key: "canvasToPlane",
    value: function canvasToPlane(canvas) {
      var plane = new Plane();
      var normal = new Vector3(0, 0, 1);
      normal.applyQuaternion(canvas.quaternion);
      plane.setFromNormalAndCoplanarPoint(normal, canvas.position.clone());
      return plane;
    }
  }, {
    key: "addCanvasFor",
    value: function addCanvasFor(scope) {
      var canvas = new Object3D();
      canvas.scale.set(1, -1, 1);
      this.canvases.set(scope, canvas);
      this.root.add(canvas);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }
    /**
     * Render the frame. Can be directly used instead of `animate` extension.
     */
  }, {
    key: "render",
    value: function render() {
      this.renderer.render(this.root, this.camera);
    }
  }, {
    key: "getCanvasFor",
    value: function getCanvasFor(scope) {
      var canvas = this.canvases.get(scope);
      if (!canvas)
        throw new Error("cannot find canvas for the scope");
      return canvas;
    }
  }, {
    key: "add",
    value: function add(object, scope) {
      object.scale.set(1, -1, 1);
      this.getCanvasFor(scope).add(object);
      if (object instanceof DraggableObject3D)
        this.controls.attach(object);
      this.render();
    }
  }, {
    key: "remove",
    value: function remove(object, scope) {
      this.getCanvasFor(scope).remove(object);
      if (object instanceof DraggableObject3D)
        this.controls.detach(object);
      this.render();
    }
  }, {
    key: "getPointerFrom",
    value: function getPointerFrom(event, scope) {
      var rect = this.container.getBoundingClientRect();
      var raycaster2 = new Raycaster();
      var pointer = new Vector2((event.clientX - rect.left) / rect.width * 2 - 1, -(event.clientY - rect.top) / rect.height * 2 + 1);
      raycaster2.setFromCamera(pointer, this.camera);
      var canvas = this.getCanvasFor(scope);
      var plane = this.canvasToPlane(canvas);
      var intersection = raycaster2.ray.intersectPlane(plane, new Vector3());
      if (intersection) {
        return canvas.worldToLocal(intersection);
      }
      return null;
    }
  }]);
  return HybridScene2;
}();
var Area = function() {
  function Area2(container, scene, scope, events, guards) {
    var _this = this;
    _classCallCheck(this, Area2);
    _defineProperty(this, "pointer", {
      x: 0,
      y: 0
    });
    _defineProperty(this, "pointerdown", function(event) {
      _this.setPointerFrom(event);
      _this.events.pointerDown(_this.pointer, event);
    });
    _defineProperty(this, "pointermove", function(event) {
      _this.setPointerFrom(event);
      _this.events.pointerMove(_this.pointer, event);
    });
    _defineProperty(this, "pointerup", function(event) {
      _this.setPointerFrom(event);
      _this.events.pointerUp(_this.pointer, event);
    });
    _defineProperty(this, "resize", function(event) {
      _this.events.resize(event);
      _this.scene.resize(_this.container.clientWidth, _this.container.clientHeight);
    });
    this.container = container;
    this.scope = scope;
    this.events = events;
    this.guards = guards;
    this.scene = scene || new HybridScene(this.container);
    this.content = new Content(this.scene, scope, function(element) {
      return _this.events.reordered(element);
    });
    this.container.addEventListener("pointerdown", this.pointerdown);
    this.container.addEventListener("pointermove", this.pointermove);
    window.addEventListener("pointerup", this.pointerup);
    window.addEventListener("resize", this.resize);
    orbitControlsRestrictor(this.scene.orbit, this.scene.camera, function(current, previous) {
      return _this.guards.transform({
        previous,
        current
      });
    }, function(current, previous) {
      return _this.events.transformed({
        previous,
        current
      });
    });
    this.scene.resize(this.container.clientWidth, this.container.clientHeight);
  }
  _createClass(Area2, [{
    key: "getCanvas",
    value: function getCanvas() {
      return this.scene.canvases.get(this.scope);
    }
    /**
     * Set the pointer position from the given mouse event into the `pointer` property
     */
  }, {
    key: "setPointerFrom",
    value: function setPointerFrom(event) {
      var point = this.scene.getPointerFrom(event, this.scope);
      if (point) {
        this.pointer = {
          x: point.x,
          y: point.y
        };
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.container.removeEventListener("pointerdown", this.pointerdown);
      this.container.removeEventListener("pointermove", this.pointermove);
      window.removeEventListener("pointerup", this.pointerup);
      window.removeEventListener("resize", this.resize);
    }
  }]);
  return Area2;
}();
var ConnectionView = _createClass(
  function ConnectionView2(events) {
    _classCallCheck(this, ConnectionView2);
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.element.style.left = "0";
    this.element.style.top = "0";
    this.element.addEventListener("contextmenu", function(event) {
      return events.contextmenu(event);
    });
    this.object = new ObjectHTML(this.element);
  }
  // public update(params?: HTML3DOptions) {
  //   setHTMLElement(this.object, this.element, {
  //     materials: {
  //       front: params?.materials?.front || createMaterial(false),
  //       back: params?.materials?.back || createBackMaterial()
  //     }
  //   })
  // }
);
var ElementsHolder = function() {
  function ElementsHolder2() {
    _classCallCheck(this, ElementsHolder2);
    _defineProperty(this, "views", /* @__PURE__ */ new WeakMap());
    _defineProperty(this, "viewsElements", /* @__PURE__ */ new Map());
  }
  _createClass(ElementsHolder2, [{
    key: "set",
    value: function set2(context) {
      var element = context.element, type = context.type, payload = context.payload;
      if (payload !== null && payload !== void 0 && payload.id) {
        this.views.set(element, context);
        this.viewsElements.set("".concat(type, "_").concat(payload.id), element);
      }
    }
  }, {
    key: "get",
    value: function get(type, id) {
      var element = this.viewsElements.get("".concat(type, "_").concat(id));
      return element && this.views.get(element);
    }
  }, {
    key: "delete",
    value: function _delete(element) {
      var _view$payload;
      var view = this.views.get(element);
      if (view && (_view$payload = view.payload) !== null && _view$payload !== void 0 && _view$payload.id) {
        this.views["delete"](element);
        this.viewsElements["delete"]("".concat(view.type, "_").concat(view.payload.id));
      }
    }
  }]);
  return ElementsHolder2;
}();
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var NodeView = function() {
  function NodeView2(events, guards) {
    var _this = this;
    _classCallCheck(this, NodeView2);
    _defineProperty(this, "translate", function() {
      var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(x, y) {
        var previous, translation;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                previous = _objectSpread$1({}, _this.position);
                _context.next = 3;
                return _this.guards.translate({
                  previous,
                  position: {
                    x,
                    y
                  }
                });
              case 3:
                translation = _context.sent;
                if (translation) {
                  _context.next = 6;
                  break;
                }
                return _context.abrupt("return", false);
              case 6:
                _this.position = _objectSpread$1({}, translation.data.position);
                _this.object.position.set(_this.position.x, _this.position.y, _this.object.position.z);
                _context.next = 10;
                return _this.events.translated({
                  position: _this.position,
                  previous
                });
              case 10:
                return _context.abrupt("return", true);
              case 11:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return function(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "resize", function() {
      var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(width, height) {
        var size, el;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                size = {
                  width,
                  height
                };
                _context2.next = 3;
                return _this.guards.resize({
                  size
                });
              case 3:
                if (_context2.sent) {
                  _context2.next = 5;
                  break;
                }
                return _context2.abrupt("return", false);
              case 5:
                el = _this.element.children.item(0);
                if (!(!el || !(el instanceof HTMLElement))) {
                  _context2.next = 8;
                  break;
                }
                return _context2.abrupt("return", false);
              case 8:
                el.style.width = "".concat(width, "px");
                el.style.height = "".concat(height, "px");
                _context2.next = 12;
                return _this.events.resized({
                  size
                });
              case 12:
                return _context2.abrupt("return", true);
              case 13:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return function(_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
    this.events = events;
    this.guards = guards;
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.position = {
      x: 0,
      y: 0
    };
    this.translate(0, 0);
    this.element.addEventListener("contextmenu", function(event) {
      return _this.events.contextmenu(event);
    });
    this.object = new DraggableObject3D(this.element, {
      start: this.events.picked,
      translate: this.translate,
      drag: this.events.dragged
    });
  }
  _createClass(NodeView2, [{
    key: "destroy",
    value: function destroy() {
    }
  }]);
  return NodeView2;
}();
function animate(area, tick) {
  function render(time) {
    if (tick)
      tick(time);
    area.area.scene.render();
    requestAnimationFrame(function(t) {
      return render(t);
    });
  }
  render(performance.now());
}
function getRoundedShape(width, height, radius) {
  var shape = new Shape();
  var x = 0;
  var y = 0;
  shape.moveTo(x + radius, y);
  shape.lineTo(x + width - radius, y);
  shape.quadraticCurveTo(x + width, y, x + width, y + radius);
  shape.lineTo(x + width, y + height - radius);
  shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  shape.lineTo(x + radius, y + height);
  shape.quadraticCurveTo(x, y + height, x, y + height - radius);
  shape.lineTo(x, y + radius);
  shape.quadraticCurveTo(x, y, x + radius, y);
  shape.closePath();
  return shape;
}
function comment(scope) {
  var commentScope = scope;
  var area = commentScope.parentScope(Area3DPlugin);
  commentScope.addPipe(function(context) {
    if (context.type === "commentcreated") {
      updateCommentGeometry(area, context.data);
    }
    if (context.type === "commenttranslated") {
      var id = context.data.id;
      var c = commentScope.comments.get(id);
      if (c) {
        updateCommentGeometry(area, c);
      }
    }
    return context;
  });
}
function commentGeometry(width, height, x, y) {
  var shape = getRoundedShape(width, height, 18);
  var geometry = new ShapeGeometry(shape);
  geometry.__commentGeometry = {
    width,
    height,
    x,
    y
  };
  geometry.translate(x, y, 0);
  return geometry;
}
function updateCommentGeometry(area, c) {
  area.area.content.updateGeometry(c.element, function(existing) {
    var meta = existing === null || existing === void 0 ? void 0 : existing.__commentGeometry;
    if (meta) {
      if (meta.width !== c.width || meta.height !== c.height) {
        return commentGeometry(c.width, c.height, c.x, c.y);
      }
      if (meta.x !== c.x || meta.y !== c.y) {
        return existing === null || existing === void 0 ? void 0 : existing.translate(c.x - meta.x, c.y - meta.y, 0);
      }
    }
    return commentGeometry(c.width, c.height, c.x, c.y);
  });
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var parseSvgPath = parse;
var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function parse(path) {
  var data = [];
  path.replace(segment, function(_, command, args) {
    var type = command.toLowerCase();
    args = parseValues(args);
    if (type == "m" && args.length > 2) {
      data.push([command].concat(args.splice(0, 2)));
      type = "l";
      command = command == "m" ? "l" : "L";
    }
    while (true) {
      if (args.length == length[type]) {
        args.unshift(command);
        return data.push(args);
      }
      if (args.length < length[type])
        throw new Error("malformed path data");
      data.push([command].concat(args.splice(0, length[type])));
    }
  });
  return data;
}
var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function parseValues(args) {
  var numbers = args.match(number);
  return numbers ? numbers.map(Number) : [];
}
var parse$1 = getDefaultExportFromCjs(parseSvgPath);
function clone(point) {
  return [point[0], point[1]];
}
function vec2(x, y) {
  return [x, y];
}
var _function = function createBezierBuilder(opt) {
  opt = opt || {};
  var RECURSION_LIMIT = typeof opt.recursion === "number" ? opt.recursion : 8;
  var FLT_EPSILON = typeof opt.epsilon === "number" ? opt.epsilon : 11920929e-14;
  var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === "number" ? opt.pathEpsilon : 1;
  var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === "number" ? opt.angleEpsilon : 0.01;
  var m_angle_tolerance = opt.angleTolerance || 0;
  var m_cusp_limit = opt.cuspLimit || 0;
  return function bezierCurve(start, c1, c2, end, scale, points) {
    if (!points)
      points = [];
    scale = typeof scale === "number" ? scale : 1;
    var distanceTolerance = PATH_DISTANCE_EPSILON / scale;
    distanceTolerance *= distanceTolerance;
    begin(start, c1, c2, end, points, distanceTolerance);
    return points;
  };
  function begin(start, c1, c2, end, points, distanceTolerance) {
    points.push(clone(start));
    var x1 = start[0], y1 = start[1], x2 = c1[0], y2 = c1[1], x3 = c2[0], y3 = c2[1], x4 = end[0], y4 = end[1];
    recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0);
    points.push(clone(end));
  }
  function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
    if (level > RECURSION_LIMIT)
      return;
    var pi = Math.PI;
    var x12 = (x1 + x2) / 2;
    var y12 = (y1 + y2) / 2;
    var x23 = (x2 + x3) / 2;
    var y23 = (y2 + y3) / 2;
    var x34 = (x3 + x4) / 2;
    var y34 = (y3 + y4) / 2;
    var x123 = (x12 + x23) / 2;
    var y123 = (y12 + y23) / 2;
    var x234 = (x23 + x34) / 2;
    var y234 = (y23 + y34) / 2;
    var x1234 = (x123 + x234) / 2;
    var y1234 = (y123 + y234) / 2;
    if (level > 0) {
      var dx = x4 - x1;
      var dy = y4 - y1;
      var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
      var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
      var da1, da2;
      if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
        if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
          if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
            points.push(vec2(x1234, y1234));
            return;
          }
          var a23 = Math.atan2(y3 - y2, x3 - x2);
          da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
          da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
          if (da1 >= pi)
            da1 = 2 * pi - da1;
          if (da2 >= pi)
            da2 = 2 * pi - da2;
          if (da1 + da2 < m_angle_tolerance) {
            points.push(vec2(x1234, y1234));
            return;
          }
          if (m_cusp_limit !== 0) {
            if (da1 > m_cusp_limit) {
              points.push(vec2(x2, y2));
              return;
            }
            if (da2 > m_cusp_limit) {
              points.push(vec2(x3, y3));
              return;
            }
          }
        }
      } else {
        if (d2 > FLT_EPSILON) {
          if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
            if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
              points.push(vec2(x1234, y1234));
              return;
            }
            da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
            if (da1 >= pi)
              da1 = 2 * pi - da1;
            if (da1 < m_angle_tolerance) {
              points.push(vec2(x2, y2));
              points.push(vec2(x3, y3));
              return;
            }
            if (m_cusp_limit !== 0) {
              if (da1 > m_cusp_limit) {
                points.push(vec2(x2, y2));
                return;
              }
            }
          }
        } else if (d3 > FLT_EPSILON) {
          if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
            if (m_angle_tolerance < curve_angle_tolerance_epsilon) {
              points.push(vec2(x1234, y1234));
              return;
            }
            da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
            if (da1 >= pi)
              da1 = 2 * pi - da1;
            if (da1 < m_angle_tolerance) {
              points.push(vec2(x2, y2));
              points.push(vec2(x3, y3));
              return;
            }
            if (m_cusp_limit !== 0) {
              if (da1 > m_cusp_limit) {
                points.push(vec2(x3, y3));
                return;
              }
            }
          }
        } else {
          dx = x1234 - (x1 + x4) / 2;
          dy = y1234 - (y1 + y4) / 2;
          if (dx * dx + dy * dy <= distanceTolerance) {
            points.push(vec2(x1234, y1234));
            return;
          }
        }
      }
    }
    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
  }
};
var adaptiveBezierCurve = _function();
var absSvgPath = absolutize;
function absolutize(path) {
  var startX = 0;
  var startY = 0;
  var x = 0;
  var y = 0;
  return path.map(function(seg) {
    seg = seg.slice();
    var type = seg[0];
    var command = type.toUpperCase();
    if (type != command) {
      seg[0] = command;
      switch (type) {
        case "a":
          seg[6] += x;
          seg[7] += y;
          break;
        case "v":
          seg[1] += y;
          break;
        case "h":
          seg[1] += x;
          break;
        default:
          for (var i = 1; i < seg.length; ) {
            seg[i++] += x;
            seg[i++] += y;
          }
      }
    }
    switch (command) {
      case "Z":
        x = startX;
        y = startY;
        break;
      case "H":
        x = seg[1];
        break;
      case "V":
        y = seg[1];
        break;
      case "M":
        x = startX = seg[1];
        y = startY = seg[2];
        break;
      default:
        x = seg[seg.length - 2];
        y = seg[seg.length - 1];
    }
    return seg;
  });
}
var  = Math.PI;
var _120 = radians(120);
var normalizeSvgPath = normalize;
function normalize(path) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y = 0;
  for (var i = 0, len = path.length; i < len; i++) {
    var seg = path[i];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        seg = arc(x, y, seg[1], seg[2], radians(seg[3]), seg[4], seg[5], seg[6], seg[7]);
        seg.unshift("C");
        if (seg.length > 7) {
          result.push(seg.splice(0, 7));
          seg.unshift("C");
        }
        break;
      case "S":
        var cx = x;
        var cy = y;
        if (prev == "C" || prev == "S") {
          cx += cx - bezierX;
          cy += cy - bezierY;
        }
        seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }
        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y, seg[1], y);
        break;
      case "V":
        seg = line(x, y, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y2) {
  return ["C", x1, y1, x2, y2, x2, y2];
}
function quadratic(x1, y1, cx, cy, x2, y2) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx,
    y1 / 3 + 2 / 3 * cy,
    x2 / 3 + 2 / 3 * cx,
    y2 / 3 + 2 / 3 * cy,
    x2,
    y2
  ];
}
function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (!recursive) {
    var xy = rotate(x1, y1, -angle);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -angle);
    x2 = xy.x;
    y2 = xy.y;
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    if (k == Infinity)
      k = 1;
    var cx = k * rx * y / ry + (x1 + x2) / 2;
    var cy = k * -ry * x / rx + (y1 + y2) / 2;
    var f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    var f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ?  - f1 : f1;
    f2 = x2 < cx ?  - f2 : f2;
    if (f1 < 0)
      f1 =  * 2 + f1;
    if (f2 < 0)
      f2 =  * 2 + f2;
    if (sweep_flag && f1 > f2)
      f1 = f1 -  * 2;
    if (!sweep_flag && f2 > f1)
      f2 = f2 -  * 2;
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  if (Math.abs(f2 - f1) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  var t = Math.tan((f2 - f1) / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var curve = [
    2 * x1 - (x1 + hx * Math.sin(f1)),
    2 * y1 - (y1 - hy * Math.cos(f1)),
    x2 + hx * Math.sin(f2),
    y2 - hy * Math.cos(f2),
    x2,
    y2
  ];
  if (recursive)
    return curve;
  if (res)
    curve = curve.concat(res);
  for (var i = 0; i < curve.length; ) {
    var rot = rotate(curve[i], curve[i + 1], angle);
    curve[i++] = rot.x;
    curve[i++] = rot.y;
  }
  return curve;
}
function rotate(x, y, rad) {
  return {
    x: x * Math.cos(rad) - y * Math.sin(rad),
    y: x * Math.sin(rad) + y * Math.cos(rad)
  };
}
function radians(degress) {
  return degress * ( / 180);
}
var vec2Copy = function vec2Copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
};
var bezier = adaptiveBezierCurve;
var abs = absSvgPath;
var norm = normalizeSvgPath;
var copy = vec2Copy;
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
var tmp1 = [0, 0];
var tmp2 = [0, 0];
var tmp3 = [0, 0];
function bezierTo(points, scale, start, seg) {
  bezier(
    start,
    set(tmp1, seg[1], seg[2]),
    set(tmp2, seg[3], seg[4]),
    set(tmp3, seg[5], seg[6]),
    scale,
    points
  );
}
var svgPathContours = function contours(svg, scale) {
  var paths = [];
  var points = [];
  var pen = [0, 0];
  norm(abs(svg)).forEach(function(segment2, i, self) {
    if (segment2[0] === "M") {
      copy(pen, segment2.slice(1));
      if (points.length > 0) {
        paths.push(points);
        points = [];
      }
    } else if (segment2[0] === "C") {
      bezierTo(points, scale, pen, segment2);
      set(pen, segment2[5], segment2[6]);
    } else {
      throw new Error("illegal type in SVG: " + segment2[0]);
    }
  });
  if (points.length > 0)
    paths.push(points);
  return paths;
};
var contours2 = getDefaultExportFromCjs(svgPathContours);
function createClassicConnectionGeometry(path, width) {
  var segments = contours2(parse$1(path));
  var points = segments.map(function(segment2) {
    return segment2.map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), x = _ref2[0], y = _ref2[1];
      return {
        x,
        y
      };
    });
  }).flat();
  var geometry = new PlaneGeometry(100, 10, points.length - 1, 1);
  for (var i = 0; i < points.length; i++) {
    var normal = new Vector2(0, width / 2);
    var point = new Vector2(points[i].x, points[i].y);
    if (i > 0 && i < points.length - 1) {
      var prevPoint = new Vector2(points[i - 1].x, points[i - 1].y);
      var nextPoint = new Vector2(points[i + 1].x, points[i + 1].y);
      var vectorBetweenPoints = nextPoint.clone().sub(prevPoint);
      var normalBetweenPoints = new Vector2(-vectorBetweenPoints.y, vectorBetweenPoints.x).clone().normalize();
      normal.set(normalBetweenPoints.x, normalBetweenPoints.y).multiplyScalar(width / 2);
    }
    geometry.attributes.position.setX(i, point.x + normal.x);
    geometry.attributes.position.setY(i, point.y + normal.y);
    geometry.attributes.position.setX(i + points.length, point.x - normal.x);
    geometry.attributes.position.setY(i + points.length, point.y - normal.y);
  }
  return geometry;
}
function connection(scope, props) {
  var renderScope = scope;
  var area = renderScope.parentScope(Area3DPlugin);
  renderScope.addPipe(function(context) {
    if (!context || _typeof(context) !== "object" || !("type" in context))
      return context;
    if (context.type === "connectionpath") {
      var id = context.data.payload.id;
      var view = area.connectionViews.get(id);
      if (view) {
        var _path = context.data.path || classicConnectionPath(context.data.points, 0.3);
        var geometry = props !== null && props !== void 0 && props.customize ? props.customize(_path) : createClassicConnectionGeometry(_path, 4.6);
        if (geometry) {
          area.area.content.updateGeometry(view.element, geometry);
        }
      }
    }
    return context;
  });
}
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index2 = geometries[i].index;
      for (let j = 0; j < index2.count; ++j) {
        mergedIndex.push(index2.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1)
      gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  const result = new BufferAttribute(array, itemSize, normalized);
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
function createClassicNodeGeometry(size, params) {
  var _ref = params || {}, _ref$borderRadius = _ref.borderRadius, borderRadius = _ref$borderRadius === void 0 ? 10 : _ref$borderRadius, _ref$inputsOffset = _ref.inputsOffset, inputsOffset = _ref$inputsOffset === void 0 ? 15.5 : _ref$inputsOffset, _ref$outputsOffset = _ref.outputsOffset, outputsOffset = _ref$outputsOffset === void 0 ? 44.5 : _ref$outputsOffset, _ref$socketRadius = _ref.socketRadius, socketRadius = _ref$socketRadius === void 0 ? 12.3 : _ref$socketRadius, _ref$socketMargin = _ref.socketMargin, socketMargin = _ref$socketMargin === void 0 ? 11.5 : _ref$socketMargin;
  var fixWidth = size.width - 1;
  var fixHeight = size.height - 1;
  var shape = getRoundedShape(fixWidth, fixHeight, borderRadius * 1.05);
  var geometry = new ShapeGeometry(shape);
  var circle = new CircleGeometry(socketRadius, 16);
  var extra = [];
  if ("inputs" in size) {
    var inputs = Object.entries(size.inputs).length;
    for (var index2 = 0; index2 < inputs; index2++) {
      var geom = circle.clone();
      var x = 1.5;
      var y = size.height - socketRadius - inputsOffset - (socketRadius * 2 + socketMargin) * index2;
      geom.translate(x, y, 0);
      extra.push(geom);
    }
  }
  if ("outputs" in size) {
    var outputs = Object.entries(size.outputs).length;
    for (var _index = 0; _index < outputs; _index++) {
      var _geom = circle.clone();
      var _x = size.width - 1.5;
      var _y = socketRadius + outputsOffset + (socketRadius * 2 + socketMargin) * _index;
      _geom.translate(_x, _y, 0);
      extra.push(_geom);
    }
  }
  return mergeGeometries([].concat(extra, [geometry]));
}
function node(area, props) {
  var editor = area.parentScope(NodeEditor);
  area.addPipe(function(context) {
    if (!context || _typeof(context) !== "object" || !("type" in context))
      return context;
    if (context.type === "render" && context.data.type === "node") {
      var id = context.data.payload.id;
      var currentNode = editor.getNode(id);
      var geometry = props !== null && props !== void 0 && props.customize ? props.customize(currentNode) : createClassicNodeGeometry(currentNode);
      area.area.content.updateGeometry(context.data.element, geometry);
    }
    return context;
  });
}
function reroute(scope) {
  if (!(scope instanceof Area3DPlugin))
    throw new Error("");
  var area = scope;
  area.addPipe(function(context) {
    if (!context || _typeof(context) !== "object" || !("type" in context))
      return context;
    if (context.type === "render" && context.data.type === "reroute-pins") {
      var pinGeometry = new CircleGeometry(10, 16);
      var pins = context.data.data.pins.map(function(pin) {
        return pinGeometry.clone().translate(pin.position.x, pin.position.y, 0);
      });
      area.area.content.updateGeometry(context.data.element, pins.length ? mergeGeometries(pins) : void 0);
    }
    return context;
  });
}
var index$1 = Object.freeze({
  __proto__: null,
  comment,
  connection,
  createClassicConnectionGeometry,
  createClassicNodeGeometry,
  node,
  reroute
});
var min = function min2(arr) {
  return arr.length === 0 ? 0 : Math.min.apply(Math, _toConsumableArray(arr));
};
var max = function max2(arr) {
  return arr.length === 0 ? 0 : Math.max.apply(Math, _toConsumableArray(arr));
};
function getBoundingBox$1(rects) {
  var left = min(rects.map(function(rect) {
    return rect.position.x;
  }));
  var top = min(rects.map(function(rect) {
    return rect.position.y;
  }));
  var right = max(rects.map(function(rect) {
    return rect.position.x + rect.width;
  }));
  var bottom = max(rects.map(function(rect) {
    return rect.position.y + rect.height;
  }));
  return {
    left,
    right,
    top,
    bottom,
    width: Math.abs(left - right),
    height: Math.abs(top - bottom),
    center: {
      x: (left + right) / 2,
      y: (top + bottom) / 2
    }
  };
}
function getNodesRect(nodes, views) {
  return nodes.map(function(node2) {
    return {
      view: views.get(node2.id),
      node: node2
    };
  }).filter(function(item) {
    return item.view;
  }).map(function(_ref) {
    var view = _ref.view, node2 = _ref.node;
    var width = node2.width, height = node2.height;
    if (typeof width !== "undefined" && typeof height !== "undefined") {
      return {
        position: view.position,
        width,
        height
      };
    }
    return {
      position: view.position,
      width: view.element.clientWidth,
      height: view.element.clientHeight
    };
  });
}
function getBoundingBox(plugin, nodes) {
  var editor = plugin.parentScope(NodeEditor);
  var list = nodes.map(function(node2) {
    return _typeof(node2) === "object" ? node2 : editor.getNode(node2);
  });
  var rects = getNodesRect(list, plugin.nodeViews);
  return getBoundingBox$1(rects);
}
function lookAt(area, nodes, params) {
  var _ref = params || {}, _ref$scale = _ref.scale, scale = _ref$scale === void 0 ? 0.9 : _ref$scale;
  var scene = area.area.scene;
  var camera = scene.camera, orbit = scene.orbit, canvases = scene.canvases;
  var canvas = canvases.get(area);
  var bbox = getBoundingBox(area, nodes);
  if (!canvas)
    throw new Error("cannot found canvas");
  var distance = getTargetDistance(camera, area.container, bbox, scale);
  var target = new Vector3(bbox.center.x, bbox.center.y, 0);
  var source = target.clone().add(new Vector3(0, 0, distance));
  canvas.localToWorld(target);
  canvas.localToWorld(source);
  camera.position.copy(source);
  orbit.target.copy(target);
  orbit.update();
}
function getTargetDistance(camera, container, size, scale) {
  var fov = camera.fov * (Math.PI / 180);
  var fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
  var dx = Math.abs(size.width / 2 / Math.tan(fovh / 2));
  var dy = Math.abs(size.height / 2 / Math.tan(fov / 2));
  var minDistance = Math.abs(container.clientHeight / 2 / Math.tan(fov / 2));
  var distance = Math.max(dx, dy, minDistance);
  return distance / scale;
}
var index = Object.freeze({
  __proto__: null,
  forms: index$1,
  animate,
  lookAt
});
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Area3DPlugin = function(_BaseAreaPlugin) {
  _inherits(Area3DPlugin2, _BaseAreaPlugin);
  var _super = _createSuper(Area3DPlugin2);
  function Area3DPlugin2(argument) {
    var _this;
    _classCallCheck(this, Area3DPlugin2);
    _this = _super.call(this, "area-3d");
    _defineProperty(_assertThisInitialized(_this), "nodeViews", /* @__PURE__ */ new Map());
    _defineProperty(_assertThisInitialized(_this), "connectionViews", /* @__PURE__ */ new Map());
    _defineProperty(_assertThisInitialized(_this), "elements", new ElementsHolder());
    _defineProperty(_assertThisInitialized(_this), "onContextMenu", function(event) {
      _this.emit({
        type: "contextmenu",
        data: {
          event,
          context: "root"
        }
      });
    });
    _this.container = argument instanceof Area3DPlugin2 ? argument.container : argument;
    _this.container.style.overflow = "hidden";
    _this.container.addEventListener("contextmenu", _this.onContextMenu);
    _this.area = new Area(_this.container, argument instanceof Area3DPlugin2 ? argument.area.scene : null, _assertThisInitialized(_this), {
      pointerDown: function pointerDown(position, event) {
        return _this.emit({
          type: "pointerdown",
          data: {
            position,
            event
          }
        });
      },
      pointerMove: function pointerMove(position, event) {
        return _this.emit({
          type: "pointermove",
          data: {
            position,
            event
          }
        });
      },
      pointerUp: function pointerUp(position, event) {
        return _this.emit({
          type: "pointerup",
          data: {
            position,
            event
          }
        });
      },
      resize: function resize(event) {
        return _this.emit({
          type: "resized",
          data: {
            event
          }
        });
      },
      transformed: function transformed(params) {
        return _this.emit({
          type: "transformed",
          data: params
        });
      },
      reordered: function reordered(element) {
        return _this.emit({
          type: "reordered",
          data: {
            element
          }
        });
      }
    }, {
      transform: function transform(params) {
        return _this.emit({
          type: "transform",
          data: params
        });
      }
    });
    _this.area.scene.addCanvasFor(_assertThisInitialized(_this));
    return _this;
  }
  _createClass(Area3DPlugin2, [{
    key: "share",
    value: function share() {
      return new Area3DPlugin2(this);
    }
  }, {
    key: "setParent",
    value: function setParent(scope) {
      var _this2 = this;
      _get(_getPrototypeOf(Area3DPlugin2.prototype), "setParent", this).call(this, scope);
      this.addPipe(function(context) {
        if (!context || !(_typeof(context) === "object" && "type" in context))
          return context;
        if (context.type === "nodecreated") {
          _this2.addNodeView(context.data);
        }
        if (context.type === "noderemoved") {
          _this2.removeNodeView(context.data.id);
        }
        if (context.type === "connectioncreated") {
          _this2.addConnectionView(context.data);
        }
        if (context.type === "connectionremoved") {
          _this2.removeConnectionView(context.data.id);
        }
        if (context.type === "render") {
          _this2.elements.set(context.data);
        }
        if (context.type === "unmount") {
          _this2.elements["delete"](context.data.element);
        }
        return context;
      });
    }
  }, {
    key: "addNodeView",
    value: function addNodeView(node2) {
      var _this3 = this;
      var id = node2.id;
      var view = new NodeView({
        picked: function picked() {
          return _this3.emit({
            type: "nodepicked",
            data: {
              id
            }
          });
        },
        translated: function translated(data) {
          return _this3.emit({
            type: "nodetranslated",
            data: _objectSpread({
              id
            }, data)
          });
        },
        dragged: function dragged() {
          return _this3.emit({
            type: "nodedragged",
            data: node2
          });
        },
        contextmenu: function contextmenu(event) {
          return _this3.emit({
            type: "contextmenu",
            data: {
              event,
              context: node2
            }
          });
        },
        resized: function resized(_ref) {
          var size = _ref.size;
          return _this3.emit({
            type: "noderesized",
            data: {
              id: node2.id,
              size
            }
          });
        }
      }, {
        translate: function translate(data) {
          return _this3.emit({
            type: "nodetranslate",
            data: _objectSpread({
              id
            }, data)
          });
        },
        resize: function resize(_ref2) {
          var size = _ref2.size;
          return _this3.emit({
            type: "noderesize",
            data: {
              id: node2.id,
              size
            }
          });
        }
      });
      this.nodeViews.set(id, view);
      this.area.content.add(view.element, view.object);
      this.emit({
        type: "render",
        data: {
          element: view.element,
          type: "node",
          payload: node2
        }
      });
      return view;
    }
  }, {
    key: "removeNodeView",
    value: function removeNodeView(id) {
      var view = this.nodeViews.get(id);
      if (view) {
        this.emit({
          type: "unmount",
          data: {
            element: view.element
          }
        });
        this.nodeViews["delete"](id);
        this.area.content.remove(view.element);
      }
    }
  }, {
    key: "addConnectionView",
    value: function addConnectionView(connection2) {
      var _this4 = this;
      var view = new ConnectionView({
        contextmenu: function contextmenu(event) {
          return _this4.emit({
            type: "contextmenu",
            data: {
              event,
              context: connection2
            }
          });
        }
      });
      this.connectionViews.set(connection2.id, view);
      this.area.content.add(view.element, view.object);
      this.emit({
        type: "render",
        data: {
          element: view.element,
          type: "connection",
          payload: connection2
        }
      });
      return view;
    }
  }, {
    key: "removeConnectionView",
    value: function removeConnectionView(id) {
      var view = this.connectionViews.get(id);
      if (view) {
        this.emit({
          type: "unmount",
          data: {
            element: view.element
          }
        });
        this.connectionViews["delete"](id);
        this.area.content.remove(view.element);
      }
    }
    /**
     * Translate node to position
     * @param id Node id
     * @param position Position
     */
  }, {
    key: "translate",
    value: function() {
      var _translate = _asyncToGenerator(import_regenerator.default.mark(function _callee(id, _ref3) {
        var x, y, view;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                x = _ref3.x, y = _ref3.y;
                view = this.nodeViews.get(id);
                if (!view) {
                  _context.next = 6;
                  break;
                }
                _context.next = 5;
                return view.translate(x, y);
              case 5:
                return _context.abrupt("return", _context.sent);
              case 6:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function translate(_x, _x2) {
        return _translate.apply(this, arguments);
      }
      return translate;
    }()
    /**
     * Resize node
     * @param id Node id
     * @param width Desired width
     * @param height Desired height
     */
  }, {
    key: "resize",
    value: function() {
      var _resize = _asyncToGenerator(import_regenerator.default.mark(function _callee2(id, width, height) {
        var view;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                view = this.nodeViews.get(id);
                if (!view) {
                  _context2.next = 5;
                  break;
                }
                _context2.next = 4;
                return view.resize(width, height);
              case 4:
                return _context2.abrupt("return", _context2.sent);
              case 5:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function resize(_x3, _x4, _x5) {
        return _resize.apply(this, arguments);
      }
      return resize;
    }()
    /**
     * Force update rendered element by id (node, connection, etc.)
     * @param type Element type
     * @param id Element id
     * @emits render
     */
  }, {
    key: "update",
    value: function() {
      var _update = _asyncToGenerator(import_regenerator.default.mark(function _callee3(type, id) {
        var data;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                data = this.elements.get(type, id);
                if (!data) {
                  _context3.next = 4;
                  break;
                }
                _context3.next = 4;
                return this.emit({
                  type: "render",
                  data
                });
              case 4:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function update(_x6, _x7) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
    /**
     * Destroy all views and remove all event listeners
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      this.container.removeEventListener("contextmenu", this.onContextMenu);
      Array.from(this.connectionViews.keys()).forEach(function(id) {
        return _this5.removeConnectionView(id);
      });
      Array.from(this.nodeViews.keys()).forEach(function(id) {
        return _this5.removeNodeView(id);
      });
      this.area.destroy();
    }
  }]);
  return Area3DPlugin2;
}(BaseAreaPlugin);
export {
  index as Area3DExtensions,
  Area3DPlugin
};
/*! Bundled license information:

rete-area-3d-plugin/area3-d-plugin.esm.js:
  (*!
  * rete-area-3d-plugin v2.0.3
  * (c) 2024 Vitaliy Stoliarov
  * Released under the MIT license.
  * *)
*/
//# sourceMappingURL=rete-area-3d-plugin.js.map
