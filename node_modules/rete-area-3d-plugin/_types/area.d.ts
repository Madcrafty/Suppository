import { Object3D } from 'three';
import { Content } from './content';
import { HybridScene } from './scene';
import { Position, Vector3D } from './types';
export declare type Transform = {
    position: Vector3D;
    rotation: Vector3D;
};
export declare type TransformEventParams = {
    previous: Transform | undefined;
    current: Transform;
};
declare type Events = {
    pointerDown: (position: Position, event: PointerEvent) => void;
    pointerMove: (position: Position, event: PointerEvent) => void;
    pointerUp: (position: Position, event: PointerEvent) => void;
    resize: (event: Event) => void;
    transformed: (params: TransformEventParams) => Promise<unknown>;
    reordered: (element: HTMLElement) => Promise<unknown>;
};
declare type Guards = {
    transform: (params: TransformEventParams) => Promise<unknown | boolean>;
};
/**
 * Area class is responsible for managing 3D scene for a current editor
 */
export declare class Area<Scope> {
    private container;
    private scope;
    private events;
    private guards;
    scene: HybridScene<Scope>;
    pointer: Position;
    content: Content<Scope>;
    constructor(container: HTMLElement, scene: HybridScene<Scope> | null, scope: Scope, events: Events, guards: Guards);
    /**
     * Get the canvas in form of Object3D for the current scope
     */
    getCanvas(): Object3D | undefined;
    /**
     * Set the pointer position from the given mouse event into the `pointer` property
     */
    setPointerFrom(event: MouseEvent): void;
    private pointerdown;
    private pointermove;
    private pointerup;
    /**
     * Force resize the container of the 3D scene
     * @param event The resize event
     */
    resize: (event: Event) => void;
    destroy(): void;
}
export {};
//# sourceMappingURL=area.d.ts.map