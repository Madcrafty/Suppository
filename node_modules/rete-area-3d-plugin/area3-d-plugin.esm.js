/*!
* rete-area-3d-plugin v2.0.3
* (c) 2024 Vitaliy Stoliarov
* Released under the MIT license.
* */
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _typeof from '@babel/runtime/helpers/typeof';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _get from '@babel/runtime/helpers/get';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { BaseAreaPlugin } from 'rete-area-plugin';
import { Vector3, Quaternion, Object3D, Matrix4, Mesh, BufferGeometry, ShadowMaterial, NoBlending, FrontSide, MeshBasicMaterial, BackSide, Raycaster, Vector2, EventDispatcher, WebGLRenderer, PCFSoftShadowMap, Ray, Plane, MathUtils, MOUSE, TOUCH, Spherical, Scene, PerspectiveCamera, Shape, ShapeGeometry, PlaneGeometry, BufferAttribute, CircleGeometry } from 'three';
import { classicConnectionPath } from 'rete-render-utils';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { NodeEditor } from 'rete';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';

/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 */

const _position = new Vector3();
const _quaternion = new Quaternion();
const _scale = new Vector3();

class CSS3DObject extends Object3D {

	constructor( element = document.createElement( 'div' ) ) {

		super();

		this.isCSS3DObject = true;

		this.element = element;
		this.element.style.position = 'absolute';
		this.element.style.pointerEvents = 'auto';
		this.element.style.userSelect = 'none';

		this.element.setAttribute( 'draggable', false );

		this.addEventListener( 'removed', function () {

			this.traverse( function ( object ) {

				if ( object.element instanceof Element && object.element.parentNode !== null ) {

					object.element.parentNode.removeChild( object.element );

				}

			} );

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.element = source.element.cloneNode( true );

		return this;

	}

}

//

const _matrix = new Matrix4();
const _matrix2 = new Matrix4();

class CSS3DRenderer {

	constructor( parameters = {} ) {

		const _this = this;

		let _width, _height;
		let _widthHalf, _heightHalf;

		const cache = {
			camera: { fov: 0, style: '' },
			objects: new WeakMap()
		};

		const domElement = parameters.element !== undefined ? parameters.element : document.createElement( 'div' );

		domElement.style.overflow = 'hidden';

		this.domElement = domElement;

		const viewElement = document.createElement( 'div' );
		viewElement.style.transformOrigin = '0 0';
		viewElement.style.pointerEvents = 'none';
		domElement.appendChild( viewElement );

		const cameraElement = document.createElement( 'div' );

		cameraElement.style.transformStyle = 'preserve-3d';

		viewElement.appendChild( cameraElement );

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.render = function ( scene, camera ) {

			const fov = camera.projectionMatrix.elements[ 5 ] * _heightHalf;

			if ( cache.camera.fov !== fov ) {

				viewElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : '';
				cache.camera.fov = fov;

			}

			if ( camera.view && camera.view.enabled ) {

				// view offset
				viewElement.style.transform = `translate( ${ - camera.view.offsetX * ( _width / camera.view.width ) }px, ${ - camera.view.offsetY * ( _height / camera.view.height ) }px )`;

				// view fullWidth and fullHeight, view width and height
				viewElement.style.transform += `scale( ${ camera.view.fullWidth / camera.view.width }, ${ camera.view.fullHeight / camera.view.height } )`;

			} else {

				viewElement.style.transform = '';

			}

			if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();
			if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

			let tx, ty;

			if ( camera.isOrthographicCamera ) {

				tx = - ( camera.right + camera.left ) / 2;
				ty = ( camera.top + camera.bottom ) / 2;

			}

			const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
			const cameraCSSMatrix = camera.isOrthographicCamera ?
				`scale( ${ scaleByViewOffset } )` + 'scale(' + fov + ')' + 'translate(' + epsilon( tx ) + 'px,' + epsilon( ty ) + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse ) :
				`scale( ${ scaleByViewOffset } )` + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix( camera.matrixWorldInverse );

			const style = cameraCSSMatrix +
				'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

			if ( cache.camera.style !== style ) {

				cameraElement.style.transform = style;

				cache.camera.style = style;

			}

			renderObject( scene, scene, camera);

		};

		this.setSize = function ( width, height ) {

			_width = width;
			_height = height;
			_widthHalf = _width / 2;
			_heightHalf = _height / 2;

			domElement.style.width = width + 'px';
			domElement.style.height = height + 'px';

			viewElement.style.width = width + 'px';
			viewElement.style.height = height + 'px';

			cameraElement.style.width = width + 'px';
			cameraElement.style.height = height + 'px';

		};

		function epsilon( value ) {

			return Math.abs( value ) < 1e-10 ? 0 : value;

		}

		function getCameraCSSMatrix( matrix ) {

			const elements = matrix.elements;

			return 'matrix3d(' +
				epsilon( elements[ 0 ] ) + ',' +
				epsilon( - elements[ 1 ] ) + ',' +
				epsilon( elements[ 2 ] ) + ',' +
				epsilon( elements[ 3 ] ) + ',' +
				epsilon( elements[ 4 ] ) + ',' +
				epsilon( - elements[ 5 ] ) + ',' +
				epsilon( elements[ 6 ] ) + ',' +
				epsilon( elements[ 7 ] ) + ',' +
				epsilon( elements[ 8 ] ) + ',' +
				epsilon( - elements[ 9 ] ) + ',' +
				epsilon( elements[ 10 ] ) + ',' +
				epsilon( elements[ 11 ] ) + ',' +
				epsilon( elements[ 12 ] ) + ',' +
				epsilon( - elements[ 13 ] ) + ',' +
				epsilon( elements[ 14 ] ) + ',' +
				epsilon( elements[ 15 ] ) +
			')';

		}

		function getObjectCSSMatrix( matrix ) {

			const elements = matrix.elements;
			const matrix3d = 'matrix3d(' +
				epsilon( elements[ 0 ] ) + ',' +
				epsilon( elements[ 1 ] ) + ',' +
				epsilon( elements[ 2 ] ) + ',' +
				epsilon( elements[ 3 ] ) + ',' +
				epsilon( - elements[ 4 ] ) + ',' +
				epsilon( - elements[ 5 ] ) + ',' +
				epsilon( - elements[ 6 ] ) + ',' +
				epsilon( - elements[ 7 ] ) + ',' +
				epsilon( elements[ 8 ] ) + ',' +
				epsilon( elements[ 9 ] ) + ',' +
				epsilon( elements[ 10 ] ) + ',' +
				epsilon( elements[ 11 ] ) + ',' +
				epsilon( elements[ 12 ] ) + ',' +
				epsilon( elements[ 13 ] ) + ',' +
				epsilon( elements[ 14 ] ) + ',' +
				epsilon( elements[ 15 ] ) +
			')';

			return 'translate(-50%,-50%)' + matrix3d;

		}

		function renderObject( object, scene, camera, cameraCSSMatrix ) {

			if ( object.isCSS3DObject ) {

				const visible = ( object.visible === true ) && ( object.layers.test( camera.layers ) === true );
				object.element.style.display = ( visible === true ) ? '' : 'none';

				if ( visible === true ) {

					object.onBeforeRender( _this, scene, camera );

					let style;

					if ( object.isCSS3DSprite ) {

						// http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

						_matrix.copy( camera.matrixWorldInverse );
						_matrix.transpose();

						if ( object.rotation2D !== 0 ) _matrix.multiply( _matrix2.makeRotationZ( object.rotation2D ) );

						object.matrixWorld.decompose( _position, _quaternion, _scale );
						_matrix.setPosition( _position );
						_matrix.scale( _scale );

						_matrix.elements[ 3 ] = 0;
						_matrix.elements[ 7 ] = 0;
						_matrix.elements[ 11 ] = 0;
						_matrix.elements[ 15 ] = 1;

						style = getObjectCSSMatrix( _matrix );

					} else {

						style = getObjectCSSMatrix( object.matrixWorld );

					}

					const element = object.element;
					const cachedObject = cache.objects.get( object );

					if ( cachedObject === undefined || cachedObject.style !== style ) {

						element.style.transform = style;

						const objectData = { style: style };
						cache.objects.set( object, objectData );

					}

					if ( element.parentNode !== cameraElement ) {

						cameraElement.appendChild( element );

					}

					object.onAfterRender( _this, scene, camera );

				}

			}

			for ( let i = 0, l = object.children.length; i < l; i ++ ) {

				renderObject( object.children[ i ], scene, camera);

			}

		}

	}

}

function flipFaces(geometry) {
  var index = geometry.getIndex();
  if (index) {
    var numTriangles = index.count / 3;
    for (var i = 0; i < numTriangles; i++) {
      var a = index.getX(i * 3 + 2);
      var b = index.getX(i * 3 + 1);
      var c = index.getX(i * 3);
      index.setXYZ(i * 3, a, b, c);
    }
  }
}

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function createMaterial(transparent) {
  return new ShadowMaterial({
    transparent: true,
    opacity: transparent ? 0.5 : 0.7,
    blending: NoBlending,
    side: FrontSide
  });
}
function createBackMaterial() {
  return new MeshBasicMaterial({
    color: 0x6e88ff,
    side: BackSide
  });
}
var ObjectHTML = /*#__PURE__*/function (_Object3D) {
  _inherits(ObjectHTML, _Object3D);
  var _super = _createSuper$3(ObjectHTML);
  function ObjectHTML(element) {
    var _this;
    _classCallCheck(this, ObjectHTML);
    _this = _super.call(this);
    _this.css3dObject = new CSS3DObject(element);
    _this.css3dObject.onAfterRender = function () {
      var internalTranslate = ' translate(50%, 50%)';
      if (!element.style.transform.endsWith(internalTranslate)) {
        element.style.transform += internalTranslate;
      }
    };
    _this.add(_this.css3dObject);
    var front = new Mesh();
    _this.front = front;
    _this.add(front);
    var back = new Mesh();
    back.castShadow = true;
    _this.back = back;
    _this.add(back);
    _this.updateMaterials();
    return _this;
  }
  _createClass(ObjectHTML, [{
    key: "updateGeometry",
    value: function updateGeometry(geometry) {
      var scaled = geometry === null || geometry === void 0 ? void 0 : geometry.clone().scale(1, -1, 1);
      if (scaled) flipFaces(scaled);
      if (this.front) this.front.geometry = scaled || new BufferGeometry();
      if (this.back) this.back.geometry = scaled || new BufferGeometry();
    }
  }, {
    key: "updateMaterials",
    value: function updateMaterials(materials) {
      if (this.front) this.front.material = (materials === null || materials === void 0 ? void 0 : materials.front) || createMaterial(false);
      if (this.back) this.back.material = (materials === null || materials === void 0 ? void 0 : materials.back) || createBackMaterial();
    }
  }]);
  return ObjectHTML;
}(Object3D);
function findTop(objects) {
  objects.sort(function (a, b) {
    if (!a.css3dObject || !b.css3dObject) return 0;
    var position = a.css3dObject.element.compareDocumentPosition(b.css3dObject.element);
    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
      return 1;
    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      return -1;
    }
    return 0;
  });
  return objects[0];
}

/**
 * Responsible for managing 2D content in the plane of 3D scene for a current editor
 */
var Content = /*#__PURE__*/function () {
  function Content(scene, scope, reordered) {
    var _scene$renderer$css3d;
    _classCallCheck(this, Content);
    _defineProperty(this, "objects", new WeakMap());
    this.scene = scene;
    this.scope = scope;
    this.reordered = reordered;
    var css3dContainer = (_scene$renderer$css3d = scene.renderer.css3d.domElement.firstElementChild) === null || _scene$renderer$css3d === void 0 ? void 0 : _scene$renderer$css3d.firstElementChild;
    if (!css3dContainer || !(css3dContainer instanceof HTMLElement)) {
      throw new Error('cannot find container for css3d element');
    }
    this.holder = css3dContainer;
  }
  _createClass(Content, [{
    key: "getPointerFrom",
    value: function getPointerFrom(event) {
      var _this$holder$getBound = this.holder.getBoundingClientRect(),
        left = _this$holder$getBound.left,
        top = _this$holder$getBound.top;
      var x = event.clientX - left;
      var y = event.clientY - top;
      return {
        x: x,
        y: y
      };
    }

    /**
     * Add an HTML element to the 3D scene
     * @param element HTML element
     */
  }, {
    key: "add",
    value: function add(element) {
      var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new ObjectHTML(element);
      this.objects.set(element, object);
      this.holder.appendChild(element);
      this.scene.add(object, this.scope);
    }

    /**
     * Reorder the given element in the 3D scene
     * @param target HTML element to reorder
     * @param next HTML element to insert before
     * @throws if `target` or `next` are not in the scene
     */
    // eslint-disable-next-line no-undef
  }, {
    key: "reorder",
    value: function () {
      var _reorder = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(target, next) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.holder.contains(target)) {
                _context.next = 2;
                break;
              }
              throw new Error("content doesn't have 'target' for reordering");
            case 2:
              if (!(next !== null && !this.holder.contains(next))) {
                _context.next = 4;
                break;
              }
              throw new Error("content doesn't have 'next' for reordering");
            case 4:
              this.holder.insertBefore(target, next);
              _context.next = 7;
              return this.reordered(target);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function reorder(_x, _x2) {
        return _reorder.apply(this, arguments);
      }
      return reorder;
    }()
    /**
     * Remove an HTML element from the 3D scene
     * @param element HTML element
     */
  }, {
    key: "remove",
    value: function remove(element) {
      var object = this.objects.get(element);
      if (object) {
        this.objects["delete"](element);
        this.scene.remove(object, this.scope);
      }
    }

    /**
     * Update the form (geometry) of the given element
     */
  }, {
    key: "updateGeometry",
    value: function updateGeometry(element, geometry) {
      var object = this.objects.get(element);
      if (object) {
        object.updateGeometry(typeof geometry === 'function' ? geometry(object.front.geometry) : geometry);
      }
    }

    /**
     * Update the material of the given element
     */
  }, {
    key: "updateMaterials",
    value: function updateMaterials(element, materials) {
      var object = this.objects.get(element);
      if (object) object.updateMaterials(materials);
    }
  }]);
  return Content;
}();

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var raycaster = new Raycaster();

// EventDispatcher should have default generic for three 152-156 compatibility
var DragControls = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(DragControls, _EventDispatcher);
  var _super = _createSuper$2(DragControls);
  function DragControls(camera, domElement, getPlane) {
    var _this;
    _classCallCheck(this, DragControls);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "enabled", true);
    _defineProperty(_assertThisInitialized(_this), "intersections", []);
    _defineProperty(_assertThisInitialized(_this), "selected", null);
    _defineProperty(_assertThisInitialized(_this), "hovered", null);
    _defineProperty(_assertThisInitialized(_this), "objects", new Set());
    _defineProperty(_assertThisInitialized(_this), "pointer", new Vector2());
    _defineProperty(_assertThisInitialized(_this), "offset", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "intersection", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "worldPosition", new Vector3());
    _defineProperty(_assertThisInitialized(_this), "inverseMatrix", new Matrix4());
    _defineProperty(_assertThisInitialized(_this), "onPointerMove", function (event) {
      if (_this.enabled === false) return;
      _this.updatePointer(event);
      raycaster.setFromCamera(_this.pointer, _this.camera);
      if (_this.selected) {
        if (raycaster.ray.intersectPlane(_this.getPlane(_this.selected), _this.intersection)) {
          var newPosition = _this.intersection.sub(_this.offset).applyMatrix4(_this.inverseMatrix);
          var eventData = {
            type: 'drag',
            object: _this.selected,
            position: newPosition
          };
          _this.dispatchEvent(eventData);
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onPointerDown", function (event) {
      if (_this.enabled === false) return;
      _this.updatePointer(event);
      _this.intersections.length = 0;
      raycaster.setFromCamera(_this.pointer, _this.camera);
      _this.intersections = raycaster.intersectObjects(_this.getObjects(), true);
      if (_this.intersections.length > 0) {
        _this.selected = _this.findIntersectedObject(_this.intersections) || null;
        if (!_this.selected) return;
        if (!_this.selected.parent) throw new Error('parent required for selected object');
        if (raycaster.ray.intersectPlane(_this.getPlane(_this.selected), _this.intersection)) {
          _this.inverseMatrix.copy(_this.selected.parent.matrixWorld).invert();
          _this.offset.copy(_this.intersection).sub(_this.worldPosition.setFromMatrixPosition(_this.selected.matrixWorld));
        }
        event.stopPropagation();
        _this.domElement.style.cursor = 'move';
        var eventData = {
          type: 'dragstart',
          object: _this.selected
        };
        _this.dispatchEvent(eventData);
      }
    });
    _defineProperty(_assertThisInitialized(_this), "onPointerCancel", function () {
      if (_this.enabled === false) return;
      if (_this.selected) {
        var eventData = {
          type: 'dragend',
          object: _this.selected
        };
        _this.dispatchEvent(eventData);
        _this.selected = null;
      }
      _this.domElement.style.cursor = _this.hovered ? 'pointer' : 'auto';
    });
    _defineProperty(_assertThisInitialized(_this), "updatePointer", function (event) {
      var rect = _this.domElement.getBoundingClientRect();
      _this.pointer.x = (event.clientX - rect.left) / rect.width * 2 - 1;
      _this.pointer.y = -(event.clientY - rect.top) / rect.height * 2 + 1;
    });
    _this.camera = camera;
    _this.domElement = domElement;
    _this.getPlane = getPlane;
    _this.domElement.style.touchAction = 'none'; // disable touch scroll
    _this.activate();
    return _this;
  }
  _createClass(DragControls, [{
    key: "attach",
    value: function attach(object) {
      this.objects.add(object);
    }
  }, {
    key: "detach",
    value: function detach(object) {
      this.objects["delete"](object);
    }
  }, {
    key: "activate",
    value: function activate() {
      this.domElement.addEventListener('pointermove', this.onPointerMove);
      this.domElement.addEventListener('pointerdown', this.onPointerDown);
      this.domElement.addEventListener('pointerup', this.onPointerCancel);
      this.domElement.addEventListener('pointerleave', this.onPointerCancel);
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      this.domElement.removeEventListener('pointermove', this.onPointerMove);
      this.domElement.removeEventListener('pointerdown', this.onPointerDown);
      this.domElement.removeEventListener('pointerup', this.onPointerCancel);
      this.domElement.removeEventListener('pointerleave', this.onPointerCancel);
      this.domElement.style.cursor = '';
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.deactivate();
    }
  }, {
    key: "getObjects",
    value: function getObjects() {
      return Array.from(this.objects.values());
    }
  }, {
    key: "getRaycaster",
    value: function getRaycaster() {
      return raycaster;
    }
  }, {
    key: "findContainer",
    value: function findContainer(intersection) {
      var object = null;
      var objects = this.getObjects();
      intersection.object.traverseAncestors(function (intersectedObject) {
        if (objects.includes(intersectedObject) && intersectedObject instanceof ObjectHTML) object = intersectedObject;
      });
      if (!object) throw new Error('cannot find Object3D');
      return object;
    }
  }, {
    key: "findIntersectedObject",
    value: function findIntersectedObject(intersections) {
      var _this2 = this;
      return findTop(intersections.map(function (i) {
        return _this2.findContainer(i);
      }));
    }
  }]);
  return DragControls;
}(EventDispatcher);

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var DraggableObject3D = /*#__PURE__*/function (_ObjectHTML) {
  _inherits(DraggableObject3D, _ObjectHTML);
  var _super = _createSuper$1(DraggableObject3D);
  function DraggableObject3D(element, events) {
    var _this;
    _classCallCheck(this, DraggableObject3D);
    _this = _super.call(this, element);
    _this.events = events;
    return _this;
  }
  return _createClass(DraggableObject3D);
}(ObjectHTML);

function attachDraggableHooks(controls) {
  controls.addEventListener('dragstart', function (e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      event.object.events.start();
    }
  });
  controls.addEventListener('drag', function (e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      var _event$position = event.position,
        x = _event$position.x,
        y = _event$position.y,
        z = _event$position.z;
      event.object.events.translate(x, y, z);
    }
  });
  controls.addEventListener('dragend', function (e) {
    var event = e;
    if (event.object instanceof DraggableObject3D) {
      event.object.events.drag();
    }
  });
}

/**
 * HybridRenderer is a wrapper for Three.js CSS3DRenderer and WebGLRenderer.
 */
var HybridRenderer = /*#__PURE__*/function () {
  /** CSS3DRenderer instance created by default */

  /** WebGLRenderer instance created by default */

  function HybridRenderer() {
    _classCallCheck(this, HybridRenderer);
    this.css3d = this.getDefaultCSS3DRenderer();
    this.webgl = this.getDefaultWebGLRenderer();
    this.domElement = document.createElement('div');
    this.css3d.domElement.setAttribute('data-css3d', 'true');
    fillAbsolute(this.domElement);
    fillAbsolute(this.css3d.domElement);
    fillAbsolute(this.webgl.domElement);
    this.domElement.appendChild(this.css3d.domElement);
    this.domElement.appendChild(this.webgl.domElement);
    this.webgl.domElement.style.pointerEvents = 'none';
  }
  _createClass(HybridRenderer, [{
    key: "getContent",
    value: function getContent() {
      return this.webgl.domElement.firstElementChild;
    }
  }, {
    key: "getDefaultCSS3DRenderer",
    value: function getDefaultCSS3DRenderer() {
      var css3d = new CSS3DRenderer();
      return css3d;
    }
  }, {
    key: "getDefaultWebGLRenderer",
    value: function getDefaultWebGLRenderer() {
      var webgl = new WebGLRenderer({
        alpha: false,
        antialias: true
      });
      webgl.setPixelRatio(window.devicePixelRatio);
      webgl.setClearColor(0xffffff, 0);
      webgl.shadowMap.enabled = true;
      webgl.shadowMap.type = PCFSoftShadowMap;
      return webgl;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.css3d.setSize(width, height);
      this.webgl.setSize(width, height);
    }
  }, {
    key: "render",
    value: function render(scene, camera) {
      this.css3d.render(scene, camera);
      this.webgl.render(scene, camera);
    }
  }]);
  return HybridRenderer;
}();
function fillAbsolute(el) {
  el.style.width = '100%';
  el.style.height = '100%';
  el.style.position = 'absolute';
  el.style.left = '0';
  el.style.top = '0';
}

// OrbitControls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

const _changeEvent = { type: 'change' };
const _startEvent = { type: 'start' };
const _endEvent = { type: 'end' };
const _ray = new Ray();
const _plane = new Plane();
const TILT_LIMIT = Math.cos( 70 * MathUtils.DEG2RAD );

class OrbitControls extends EventDispatcher {

	constructor( object, domElement ) {

		super();

		this.object = object;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
		this.zoomToCursor = false;

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60

		// The four arrow keys
		this.keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		// the target DOM element for key events
		this._domElementKeyEvents = null;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.getDistance = function () {

			return this.object.position.distanceTo( this.target );

		};

		this.listenToKeyEvents = function ( domElement ) {

			domElement.addEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = domElement;

		};

		this.stopListenToKeyEvents = function () {

			this._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
			this._domElementKeyEvents = null;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( _changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			const offset = new Vector3();

			// so camera.up is the orbit axis
			const quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			const quatInverse = quat.clone().invert();

			const lastPosition = new Vector3();
			const lastQuaternion = new Quaternion();
			const lastTargetPosition = new Vector3();

			const twoPI = 2 * Math.PI;

			return function update( deltaTime = null ) {

				const position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle( deltaTime ) );

				}

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits

				let min = scope.minAzimuthAngle;
				let max = scope.maxAzimuthAngle;

				if ( isFinite( min ) && isFinite( max ) ) {

					if ( min < - Math.PI ) min += twoPI; else if ( min > Math.PI ) min -= twoPI;

					if ( max < - Math.PI ) max += twoPI; else if ( max > Math.PI ) max -= twoPI;

					if ( min <= max ) {

						spherical.theta = Math.max( min, Math.min( max, spherical.theta ) );

					} else {

						spherical.theta = ( spherical.theta > ( min + max ) / 2 ) ?
							Math.max( min, spherical.theta ) :
							Math.min( max, spherical.theta );

					}

				}

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				// adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera
				// we adjust zoom later in these cases
				if ( scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera ) {

					spherical.radius = clampDistance( spherical.radius );

				} else {

					spherical.radius = clampDistance( spherical.radius * scale );

				}


				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

				// adjust camera position
				let zoomChanged = false;
				if ( scope.zoomToCursor && performCursorZoom ) {

					let newRadius = null;
					if ( scope.object.isPerspectiveCamera ) {

						// move the camera down the pointer ray
						// this method avoids floating point error
						const prevRadius = offset.length();
						newRadius = clampDistance( prevRadius * scale );

						const radiusDelta = prevRadius - newRadius;
						scope.object.position.addScaledVector( dollyDirection, radiusDelta );
						scope.object.updateMatrixWorld();

					} else if ( scope.object.isOrthographicCamera ) {

						// adjust the ortho camera position based on zoom changes
						const mouseBefore = new Vector3( mouse.x, mouse.y, 0 );
						mouseBefore.unproject( scope.object );

						scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
						scope.object.updateProjectionMatrix();
						zoomChanged = true;

						const mouseAfter = new Vector3( mouse.x, mouse.y, 0 );
						mouseAfter.unproject( scope.object );

						scope.object.position.sub( mouseAfter ).add( mouseBefore );
						scope.object.updateMatrixWorld();

						newRadius = offset.length();

					} else {

						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.' );
						scope.zoomToCursor = false;

					}

					// handle the placement of the target
					if ( newRadius !== null ) {

						if ( this.screenSpacePanning ) {

							// position the orbit target in front of the new camera position
							scope.target.set( 0, 0, - 1 )
								.transformDirection( scope.object.matrix )
								.multiplyScalar( newRadius )
								.add( scope.object.position );

						} else {

							// get the ray and translation plane to compute target
							_ray.origin.copy( scope.object.position );
							_ray.direction.set( 0, 0, - 1 ).transformDirection( scope.object.matrix );

							// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid
							// extremely large values
							if ( Math.abs( scope.object.up.dot( _ray.direction ) ) < TILT_LIMIT ) {

								object.lookAt( scope.target );

							} else {

								_plane.setFromNormalAndCoplanarPoint( scope.object.up, scope.target );
								_ray.intersectPlane( _plane, scope.target );

							}

						}

					}

				} else if ( scope.object.isOrthographicCamera ) {

					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / scale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;

				}

				scale = 1;
				performCursorZoom = false;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ||
					lastTargetPosition.distanceToSquared( scope.target ) > 0 ) {

					scope.dispatchEvent( _changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					lastTargetPosition.copy( scope.target );

					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu );

			scope.domElement.removeEventListener( 'pointerdown', onPointerDown );
			scope.domElement.removeEventListener( 'pointercancel', onPointerUp );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel );

			scope.domElement.removeEventListener( 'pointermove', onPointerMove );
			scope.domElement.removeEventListener( 'pointerup', onPointerUp );


			if ( scope._domElementKeyEvents !== null ) {

				scope._domElementKeyEvents.removeEventListener( 'keydown', onKeyDown );
				scope._domElementKeyEvents = null;

			}

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		const scope = this;

		const STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		let state = STATE.NONE;

		const EPS = 0.000001;

		// current position in spherical coordinates
		const spherical = new Spherical();
		const sphericalDelta = new Spherical();

		let scale = 1;
		const panOffset = new Vector3();

		const rotateStart = new Vector2();
		const rotateEnd = new Vector2();
		const rotateDelta = new Vector2();

		const panStart = new Vector2();
		const panEnd = new Vector2();
		const panDelta = new Vector2();

		const dollyStart = new Vector2();
		const dollyEnd = new Vector2();
		const dollyDelta = new Vector2();

		const dollyDirection = new Vector3();
		const mouse = new Vector2();
		let performCursorZoom = false;

		const pointers = [];
		const pointerPositions = {};

		function getAutoRotationAngle( deltaTime ) {

			if ( deltaTime !== null ) {

				return ( 2 * Math.PI / 60 * scope.autoRotateSpeed ) * deltaTime;

			} else {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		const panLeft = function () {

			const v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		const panUp = function () {

			const v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		const pan = function () {

			const offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				const element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					const position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					let targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale /= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera || scope.object.isOrthographicCamera ) {

				scale *= dollyScale;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function updateMouseParameters( event ) {

			if ( ! scope.zoomToCursor ) {

				return;

			}

			performCursorZoom = true;

			const rect = scope.domElement.getBoundingClientRect();
			const x = event.clientX - rect.left;
			const y = event.clientY - rect.top;
			const w = rect.width;
			const h = rect.height;

			mouse.x = ( x / w ) * 2 - 1;
			mouse.y = - ( y / h ) * 2 + 1;

			dollyDirection.set( mouse.x, mouse.y, 1 ).unproject( scope.object ).sub( scope.object.position ).normalize();

		}

		function clampDistance( dist ) {

			return Math.max( scope.minDistance, Math.min( scope.maxDistance, dist ) );

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			updateMouseParameters( event );
			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseWheel( event ) {

			updateMouseParameters( event );

			if ( event.deltaY < 0 ) {

				dollyIn( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyOut( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			let needsUpdate = false;

			switch ( event.code ) {

				case scope.keys.UP:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateUp( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( 0, - scope.keyPanSpeed );

					}

					needsUpdate = true;
					break;

				case scope.keys.LEFT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

				case scope.keys.RIGHT:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						rotateLeft( - 2 * Math.PI * scope.rotateSpeed / scope.domElement.clientHeight );

					} else {

						pan( - scope.keyPanSpeed, 0 );

					}

					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate() {

			if ( pointers.length === 1 ) {

				rotateStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan() {

			if ( pointers.length === 1 ) {

				panStart.set( pointers[ 0 ].pageX, pointers[ 0 ].pageY );

			} else {

				const x = 0.5 * ( pointers[ 0 ].pageX + pointers[ 1 ].pageX );
				const y = 0.5 * ( pointers[ 0 ].pageY + pointers[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly() {

			const dx = pointers[ 0 ].pageX - pointers[ 1 ].pageX;
			const dy = pointers[ 0 ].pageY - pointers[ 1 ].pageY;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enablePan ) handleTouchStartPan();

		}

		function handleTouchStartDollyRotate() {

			if ( scope.enableZoom ) handleTouchStartDolly();

			if ( scope.enableRotate ) handleTouchStartRotate();

		}

		function handleTouchMoveRotate( event ) {

			if ( pointers.length == 1 ) {

				rotateEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			const element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( pointers.length === 1 ) {

				panEnd.set( event.pageX, event.pageY );

			} else {

				const position = getSecondPointerPosition( event );

				const x = 0.5 * ( event.pageX + position.x );
				const y = 0.5 * ( event.pageY + position.y );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			const position = getSecondPointerPosition( event );

			const dx = event.pageX - position.x;
			const dy = event.pageY - position.y;

			const distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onPointerDown( event ) {

			if ( scope.enabled === false ) return;

			if ( pointers.length === 0 ) {

				scope.domElement.setPointerCapture( event.pointerId );

				scope.domElement.addEventListener( 'pointermove', onPointerMove );
				scope.domElement.addEventListener( 'pointerup', onPointerUp );

			}

			//

			addPointer( event );

			if ( event.pointerType === 'touch' ) {

				onTouchStart( event );

			} else {

				onMouseDown( event );

			}

		}

		function onPointerMove( event ) {

			if ( scope.enabled === false ) return;

			if ( event.pointerType === 'touch' ) {

				onTouchMove( event );

			} else {

				onMouseMove( event );

			}

		}

		function onPointerUp( event ) {

			removePointer( event );

			if ( pointers.length === 0 ) {

				scope.domElement.releasePointerCapture( event.pointerId );

				scope.domElement.removeEventListener( 'pointermove', onPointerMove );
				scope.domElement.removeEventListener( 'pointerup', onPointerUp );

			}

			scope.dispatchEvent( _endEvent );

			state = STATE.NONE;

		}

		function onMouseDown( event ) {

			let mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onMouseMove( event ) {

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;

			event.preventDefault();

			scope.dispatchEvent( _startEvent );

			handleMouseWheel( event );

			scope.dispatchEvent( _endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			trackPointer( event );

			switch ( pointers.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate();

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan();

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan();

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate();

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( _startEvent );

			}

		}

		function onTouchMove( event ) {

			trackPointer( event );

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		function addPointer( event ) {

			pointers.push( event );

		}

		function removePointer( event ) {

			delete pointerPositions[ event.pointerId ];

			for ( let i = 0; i < pointers.length; i ++ ) {

				if ( pointers[ i ].pointerId == event.pointerId ) {

					pointers.splice( i, 1 );
					return;

				}

			}

		}

		function trackPointer( event ) {

			let position = pointerPositions[ event.pointerId ];

			if ( position === undefined ) {

				position = new Vector2();
				pointerPositions[ event.pointerId ] = position;

			}

			position.set( event.pageX, event.pageY );

		}

		function getSecondPointerPosition( event ) {

			const pointer = ( event.pointerId === pointers[ 0 ].pointerId ) ? pointers[ 1 ] : pointers[ 0 ];

			return pointerPositions[ pointer.pointerId ];

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu );

		scope.domElement.addEventListener( 'pointerdown', onPointerDown );
		scope.domElement.addEventListener( 'pointercancel', onPointerUp );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, { passive: false } );

		// force an update at start

		this.update();

	}

}

function orbitControlsRestrictor(orbit, camera, check, updated) {
  var previous;
  var previousTarget;

  // eslint-disable-next-line max-statements
  orbit.addEventListener('change', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var position, rotation, _previous, p, r, t;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          position = camera.position.clone();
          rotation = camera.rotation.clone();
          _context.next = 4;
          return check({
            position: position,
            rotation: rotation
          }, previous);
        case 4:
          if (!_context.sent) {
            _context.next = 9;
            break;
          }
          previous = {
            position: position,
            rotation: rotation
          };
          previousTarget = orbit.target.clone();
          _context.next = 13;
          break;
        case 9:
          if (previous && previousTarget) {
            _previous = previous, p = _previous.position, r = _previous.rotation;
            t = previousTarget;
            camera.position.fromArray([p.x, p.y, p.z]);
            camera.rotation.fromArray([r.x, r.y, r.z]);
            orbit.target.fromArray([t.x, t.y, t.z]);
          }
          orbit.update();
          _context.next = 13;
          return updated({
            position: position,
            rotation: rotation
          }, previous);
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
}

/**
 * HybridScene is a wrapper for Three.js Scene with some additional features such as:
 * - drag controls
 * - orbit controls
 * - camera
 * - renderer
 */
var HybridScene = /*#__PURE__*/function () {
  function HybridScene(container) {
    _classCallCheck(this, HybridScene);
    _defineProperty(this, "root", new Scene());
    _defineProperty(this, "canvases", new Map());
    this.container = container;
    this.camera = new PerspectiveCamera();
    this.camera.position.set(0, 0, 1000);
    this.camera.fov = 45;
    this.camera.near = 1;
    this.camera.far = 4000;
    this.renderer = new HybridRenderer();
    container.appendChild(this.renderer.domElement);
    this.orbit = this.createOrbitControls();
    this.controls = this.createDragControls(this.orbit);
  }
  _createClass(HybridScene, [{
    key: "createOrbitControls",
    value: function createOrbitControls() {
      var orbit = new OrbitControls(this.camera, this.renderer.domElement);
      orbit.update();
      var orbitChangeNumber = 0;
      orbit.addEventListener('start', function () {
        orbitChangeNumber = 0;
      });
      orbit.addEventListener('change', function () {
        orbitChangeNumber++;
      });
      this.renderer.domElement.addEventListener('contextmenu', function (e) {
        if (orbitChangeNumber > 5) e.stopPropagation();
      });
      return orbit;
    }
  }, {
    key: "createDragControls",
    value: function createDragControls(orbit) {
      var _this = this;
      var controls = new DragControls(this.camera, this.renderer.domElement, function (object) {
        var canvas = object.parent;
        if (!canvas) throw new Error('object doesnt have parent');
        if (!Array.from(_this.canvases.values()).includes(canvas)) throw new Error('object parent isnt canvas');
        return _this.canvasToPlane(canvas);
      });
      attachDraggableHooks(controls);
      controls.addEventListener('dragstart', function () {
        return orbit.enabled = false;
      });
      controls.addEventListener('dragend', function () {
        return orbit.enabled = true;
      });
      return controls;
    }
  }, {
    key: "canvasToPlane",
    value: function canvasToPlane(canvas) {
      var plane = new Plane();
      var normal = new Vector3(0, 0, 1);
      normal.applyQuaternion(canvas.quaternion);
      plane.setFromNormalAndCoplanarPoint(normal, canvas.position.clone());
      return plane;
    }
  }, {
    key: "addCanvasFor",
    value: function addCanvasFor(scope) {
      var canvas = new Object3D();
      canvas.scale.set(1, -1, 1);
      this.canvases.set(scope, canvas);
      this.root.add(canvas);
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }

    /**
     * Render the frame. Can be directly used instead of `animate` extension.
     */
  }, {
    key: "render",
    value: function render() {
      this.renderer.render(this.root, this.camera);
    }
  }, {
    key: "getCanvasFor",
    value: function getCanvasFor(scope) {
      var canvas = this.canvases.get(scope);
      if (!canvas) throw new Error('cannot find canvas for the scope');
      return canvas;
    }
  }, {
    key: "add",
    value: function add(object, scope) {
      object.scale.set(1, -1, 1);
      this.getCanvasFor(scope).add(object);
      if (object instanceof DraggableObject3D) this.controls.attach(object);
      this.render(); // force DOM elements to be rendered synchronously
    }
  }, {
    key: "remove",
    value: function remove(object, scope) {
      this.getCanvasFor(scope).remove(object);
      if (object instanceof DraggableObject3D) this.controls.detach(object);
      this.render(); // force DOM elements to be rendered synchronously
    }
  }, {
    key: "getPointerFrom",
    value: function getPointerFrom(event, scope) {
      var rect = this.container.getBoundingClientRect();
      var raycaster = new Raycaster();
      var pointer = new Vector2((event.clientX - rect.left) / rect.width * 2 - 1, -(event.clientY - rect.top) / rect.height * 2 + 1);
      raycaster.setFromCamera(pointer, this.camera);
      var canvas = this.getCanvasFor(scope);
      var plane = this.canvasToPlane(canvas);
      var intersection = raycaster.ray.intersectPlane(plane, new Vector3());
      if (intersection) {
        return canvas.worldToLocal(intersection);
      }
      return null;
    }
  }]);
  return HybridScene;
}();

/**
 * Area class is responsible for managing 3D scene for a current editor
 */
var Area = /*#__PURE__*/function () {
  function Area(container, scene, scope, events, guards) {
    var _this = this;
    _classCallCheck(this, Area);
    _defineProperty(this, "pointer", {
      x: 0,
      y: 0
    });
    _defineProperty(this, "pointerdown", function (event) {
      _this.setPointerFrom(event);
      _this.events.pointerDown(_this.pointer, event);
    });
    _defineProperty(this, "pointermove", function (event) {
      _this.setPointerFrom(event);
      _this.events.pointerMove(_this.pointer, event);
    });
    _defineProperty(this, "pointerup", function (event) {
      _this.setPointerFrom(event);
      _this.events.pointerUp(_this.pointer, event);
    });
    /**
     * Force resize the container of the 3D scene
     * @param event The resize event
     */
    _defineProperty(this, "resize", function (event) {
      _this.events.resize(event);
      _this.scene.resize(_this.container.clientWidth, _this.container.clientHeight);
    });
    this.container = container;
    this.scope = scope;
    this.events = events;
    this.guards = guards;
    this.scene = scene || new HybridScene(this.container);
    this.content = new Content(this.scene, scope, function (element) {
      return _this.events.reordered(element);
    });
    this.container.addEventListener('pointerdown', this.pointerdown);
    this.container.addEventListener('pointermove', this.pointermove);
    window.addEventListener('pointerup', this.pointerup);
    window.addEventListener('resize', this.resize);
    orbitControlsRestrictor(this.scene.orbit, this.scene.camera, function (current, previous) {
      return _this.guards.transform({
        previous: previous,
        current: current
      });
    }, function (current, previous) {
      return _this.events.transformed({
        previous: previous,
        current: current
      });
    });
    this.scene.resize(this.container.clientWidth, this.container.clientHeight);
  }

  /**
   * Get the canvas in form of Object3D for the current scope
   */
  _createClass(Area, [{
    key: "getCanvas",
    value: function getCanvas() {
      return this.scene.canvases.get(this.scope);
    }

    /**
     * Set the pointer position from the given mouse event into the `pointer` property
     */
  }, {
    key: "setPointerFrom",
    value: function setPointerFrom(event) {
      var point = this.scene.getPointerFrom(event, this.scope);
      if (point) {
        this.pointer = {
          x: point.x,
          y: point.y
        };
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.container.removeEventListener('pointerdown', this.pointerdown);
      this.container.removeEventListener('pointermove', this.pointermove);
      window.removeEventListener('pointerup', this.pointerup);
      window.removeEventListener('resize', this.resize);
    }
  }]);
  return Area;
}();

var ConnectionView = /*#__PURE__*/_createClass(function ConnectionView(events) {
  _classCallCheck(this, ConnectionView);
  this.element = document.createElement('div');
  this.element.style.position = 'absolute';
  this.element.style.left = '0';
  this.element.style.top = '0';
  this.element.addEventListener('contextmenu', function (event) {
    return events.contextmenu(event);
  });
  this.object = new ObjectHTML(this.element);
}

// public update(params?: HTML3DOptions) {
//   setHTMLElement(this.object, this.element, {
//     materials: {
//       front: params?.materials?.front || createMaterial(false),
//       back: params?.materials?.back || createBackMaterial()
//     }
//   })
// }
);

var ElementsHolder = /*#__PURE__*/function () {
  function ElementsHolder() {
    _classCallCheck(this, ElementsHolder);
    _defineProperty(this, "views", new WeakMap());
    _defineProperty(this, "viewsElements", new Map());
  }
  _createClass(ElementsHolder, [{
    key: "set",
    value: function set(context) {
      var element = context.element,
        type = context.type,
        payload = context.payload;
      if (payload !== null && payload !== void 0 && payload.id) {
        this.views.set(element, context);
        this.viewsElements.set("".concat(type, "_").concat(payload.id), element);
      }
    }
  }, {
    key: "get",
    value: function get(type, id) {
      var element = this.viewsElements.get("".concat(type, "_").concat(id));
      return element && this.views.get(element);
    }
  }, {
    key: "delete",
    value: function _delete(element) {
      var _view$payload;
      var view = this.views.get(element);
      if (view && (_view$payload = view.payload) !== null && _view$payload !== void 0 && _view$payload.id) {
        this.views["delete"](element);
        this.viewsElements["delete"]("".concat(view.type, "_").concat(view.payload.id));
      }
    }
  }]);
  return ElementsHolder;
}();

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var NodeView = /*#__PURE__*/function () {
  function NodeView(events, guards) {
    var _this = this;
    _classCallCheck(this, NodeView);
    _defineProperty(this, "translate", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(x, y) {
        var previous, translation;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              previous = _objectSpread$1({}, _this.position);
              _context.next = 3;
              return _this.guards.translate({
                previous: previous,
                position: {
                  x: x,
                  y: y
                }
              });
            case 3:
              translation = _context.sent;
              if (translation) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", false);
            case 6:
              _this.position = _objectSpread$1({}, translation.data.position);
              _this.object.position.set(_this.position.x, _this.position.y, _this.object.position.z);
              _context.next = 10;
              return _this.events.translated({
                position: _this.position,
                previous: previous
              });
            case 10:
              return _context.abrupt("return", true);
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    _defineProperty(this, "resize", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(width, height) {
        var size, el;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              size = {
                width: width,
                height: height
              };
              _context2.next = 3;
              return _this.guards.resize({
                size: size
              });
            case 3:
              if (_context2.sent) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return", false);
            case 5:
              el = _this.element.children.item(0);
              if (!(!el || !(el instanceof HTMLElement))) {
                _context2.next = 8;
                break;
              }
              return _context2.abrupt("return", false);
            case 8:
              el.style.width = "".concat(width, "px");
              el.style.height = "".concat(height, "px");
              _context2.next = 12;
              return _this.events.resized({
                size: size
              });
            case 12:
              return _context2.abrupt("return", true);
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
    this.events = events;
    this.guards = guards;
    this.element = document.createElement('div');
    this.element.style.position = 'absolute';
    this.position = {
      x: 0,
      y: 0
    };
    this.translate(0, 0);
    this.element.addEventListener('contextmenu', function (event) {
      return _this.events.contextmenu(event);
    });
    this.object = new DraggableObject3D(this.element, {
      start: this.events.picked,
      translate: this.translate,
      drag: this.events.dragged
    });
  }
  _createClass(NodeView, [{
    key: "destroy",
    value: function destroy() {
    }
  }]);
  return NodeView;
}();

/**
 * Animate the given 3D scene, uses `requestAnimationFrame`
 * @param area The 3D area plugin
 * @param tick Optional callback to be called on each frame
 * @example Area3DExtensions.animate(area)
 * @example Area3DExtensions.animate(area, time => console.log(time))
 */
function animate(area, tick) {
  function render(time) {
    if (tick) tick(time);
    area.area.scene.render();
    requestAnimationFrame(function (t) {
      return render(t);
    });
  }
  render(performance.now());
}

// eslint-disable-next-line max-statements
function getRoundedShape(width, height, radius) {
  var shape = new Shape();
  var x = 0;
  var y = 0;
  shape.moveTo(x + radius, y);
  shape.lineTo(x + width - radius, y);
  shape.quadraticCurveTo(x + width, y, x + width, y + radius);
  shape.lineTo(x + width, y + height - radius);
  shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  shape.lineTo(x + radius, y + height);
  shape.quadraticCurveTo(x, y + height, x, y + height - radius);
  shape.lineTo(x, y + radius);
  shape.quadraticCurveTo(x, y, x + radius, y);
  shape.closePath();
  return shape;
}

/**
 * Form generator for embedding rete-comment-plugin into 3D scene.
 * @param scope Area3DPlugin instance
 */
function comment(scope) {
  var commentScope = scope;
  var area = commentScope.parentScope(Area3DPlugin);
  commentScope.addPipe(function (context) {
    if (context.type === 'commentcreated') {
      updateCommentGeometry(area, context.data);
    }
    if (context.type === 'commenttranslated') {
      var id = context.data.id;
      var c = commentScope.comments.get(id);
      if (c) {
        updateCommentGeometry(area, c);
      }
    }
    return context;
  });
}
function commentGeometry(width, height, x, y) {
  var shape = getRoundedShape(width, height, 18);
  var geometry = new ShapeGeometry(shape);
  geometry.__commentGeometry = {
    width: width,
    height: height,
    x: x,
    y: y
  };
  geometry.translate(x, y, 0);
  return geometry;
}
function updateCommentGeometry(area, c) {
  area.area.content.updateGeometry(c.element, function (existing) {
    var meta = existing === null || existing === void 0 ? void 0 : existing.__commentGeometry;
    if (meta) {
      if (meta.width !== c.width || meta.height !== c.height) {
        return commentGeometry(c.width, c.height, c.x, c.y);
      }
      if (meta.x !== c.x || meta.y !== c.y) {
        return existing === null || existing === void 0 ? void 0 : existing.translate(c.x - meta.x, c.y - meta.y, 0);
      }
    }
    return commentGeometry(c.width, c.height, c.x, c.y);
  });
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var parseSvgPath = parse;

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0};

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = [];
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase();
		args = parseValues(args);

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)));
			type = 'l';
			command = command == 'm' ? 'l' : 'L';
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command);
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])));
		}
	});
	return data
}

var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

function parseValues(args) {
	var numbers = args.match(number);
	return numbers ? numbers.map(Number) : []
}

var parse$1 = /*@__PURE__*/getDefaultExportFromCjs(parseSvgPath);

function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

var _function = function createBezierBuilder(opt) {
    opt = opt||{};

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8;
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7;
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0;

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01;
    var m_angle_tolerance = opt.angleTolerance || 0;
    var m_cusp_limit = opt.cuspLimit || 0;

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = [];

        scale = typeof scale === 'number' ? scale : 1.0;
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale;
        distanceTolerance *= distanceTolerance;
        begin(start, c1, c2, end, points, distanceTolerance);
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start));
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1];
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0);
        points.push(clone(end));
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI;

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2;
        var y12   = (y1 + y2) / 2;
        var x23   = (x2 + x3) / 2;
        var y23   = (y2 + y3) / 2;
        var x34   = (x3 + x4) / 2;
        var y34   = (y3 + y4) / 2;
        var x123  = (x12 + x23) / 2;
        var y123  = (y12 + y23) / 2;
        var x234  = (x23 + x34) / 2;
        var y234  = (y23 + y34) / 2;
        var x1234 = (x123 + x234) / 2;
        var y1234 = (y123 + y234) / 2;

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1;
            var dy = y4-y1;

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);

            var da1, da2;

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234));
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2);
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);
                    if(da1 >= pi) da1 = 2*pi - da1;
                    if(da2 >= pi) da2 = 2*pi - da2;

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234));
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2));
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3));
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234));
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));
                        if(da1 >= pi) da1 = 2*pi - da1;

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2));
                            points.push(vec2(x3, y3));
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2));
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234));
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));
                        if(da1 >= pi) da1 = 2*pi - da1;

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2));
                            points.push(vec2(x3, y3));
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3));
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2;
                    dy = y1234 - (y1 + y4) / 2;
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234));
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1); 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1); 
    }
};

var adaptiveBezierCurve = _function();

var absSvgPath = absolutize;

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0;
	var startY = 0;
	var x = 0;
	var y = 0;

	return path.map(function(seg){
		seg = seg.slice();
		var type = seg[0];
		var command = type.toUpperCase();

		// is relative
		if (type != command) {
			seg[0] = command;
			switch (type) {
				case 'a':
					seg[6] += x;
					seg[7] += y;
					break
				case 'v':
					seg[1] += y;
					break
				case 'h':
					seg[1] += x;
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x;
						seg[i++] += y;
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX;
				y = startY;
				break
			case 'H':
				x = seg[1];
				break
			case 'V':
				y = seg[1];
				break
			case 'M':
				x = startX = seg[1];
				y = startY = seg[2];
				break
			default:
				x = seg[seg.length - 2];
				y = seg[seg.length - 1];
		}

		return seg
	})
}

var π = Math.PI;
var _120 = radians(120);

var normalizeSvgPath = normalize;

/**
 * describe `path` in terms of cubic bézier 
 * curves and move commands
 *
 * @param {Array} path
 * @return {Array}
 */

function normalize(path){
	// init state
	var prev;
	var result = [];
	var bezierX = 0;
	var bezierY = 0;
	var startX = 0;
	var startY = 0;
	var quadX = null;
	var quadY = null;
	var x = 0;
	var y = 0;

	for (var i = 0, len = path.length; i < len; i++) {
		var seg = path[i];
		var command = seg[0];
		switch (command) {
			case 'M':
				startX = seg[1];
				startY = seg[2];
				break
			case 'A':
				seg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7]);
				// split multi part
				seg.unshift('C');
				if (seg.length > 7) {
					result.push(seg.splice(0, 7));
					seg.unshift('C');
				}
				break
			case 'S':
				// default control point
				var cx = x;
				var cy = y;
				if (prev == 'C' || prev == 'S') {
					cx += cx - bezierX; // reflect the previous command's control
					cy += cy - bezierY; // point relative to the current point
				}
				seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];
				break
			case 'T':
				if (prev == 'Q' || prev == 'T') {
					quadX = x * 2 - quadX; // as with 'S' reflect previous control point
					quadY = y * 2 - quadY;
				} else {
					quadX = x;
					quadY = y;
				}
				seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
				break
			case 'Q':
				quadX = seg[1];
				quadY = seg[2];
				seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
				break
			case 'L':
				seg = line(x, y, seg[1], seg[2]);
				break
			case 'H':
				seg = line(x, y, seg[1], y);
				break
			case 'V':
				seg = line(x, y, x, seg[1]);
				break
			case 'Z':
				seg = line(x, y, startX, startY);
				break
		}

		// update state
		prev = command;
		x = seg[seg.length - 2];
		y = seg[seg.length - 1];
		if (seg.length > 4) {
			bezierX = seg[seg.length - 4];
			bezierY = seg[seg.length - 3];
		} else {
			bezierX = x;
			bezierY = y;
		}
		result.push(seg);
	}

	return result
}

function line(x1, y1, x2, y2){
	return ['C', x1, y1, x2, y2, x2, y2]
}

function quadratic(x1, y1, cx, cy, x2, y2){
	return [
		'C',
		x1/3 + (2/3) * cx,
		y1/3 + (2/3) * cy,
		x2/3 + (2/3) * cx,
		y2/3 + (2/3) * cy,
		x2,
		y2
	]
}

// This function is ripped from 
// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 
// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// TODO: make it human readable

function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (!recursive) {
		var xy = rotate(x1, y1, -angle);
		x1 = xy.x;
		y1 = xy.y;
		xy = rotate(x2, y2, -angle);
		x2 = xy.x;
		y2 = xy.y;
		var x = (x1 - x2) / 2;
		var y = (y1 - y2) / 2;
		var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
		if (h > 1) {
			h = Math.sqrt(h);
			rx = h * rx;
			ry = h * ry;
		}
		var rx2 = rx * rx;
		var ry2 = ry * ry;
		var k = (large_arc_flag == sweep_flag ? -1 : 1)
			* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
		if (k == Infinity) k = 1; // neutralize
		var cx = k * rx * y / ry + (x1 + x2) / 2;
		var cy = k * -ry * x / rx + (y1 + y2) / 2;
		var f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
		var f2 = Math.asin(((y2 - cy) / ry).toFixed(9));

		f1 = x1 < cx ? π - f1 : f1;
		f2 = x2 < cx ? π - f2 : f2;
		if (f1 < 0) f1 = π * 2 + f1;
		if (f2 < 0) f2 = π * 2 + f2;
		if (sweep_flag && f1 > f2) f1 = f1 - π * 2;
		if (!sweep_flag && f2 > f1) f2 = f2 - π * 2;
	} else {
		f1 = recursive[0];
		f2 = recursive[1];
		cx = recursive[2];
		cy = recursive[3];
	}
	// greater than 120 degrees requires multiple segments
	if (Math.abs(f2 - f1) > _120) {
		var f2old = f2;
		var x2old = x2;
		var y2old = y2;
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
		x2 = cx + rx * Math.cos(f2);
		y2 = cy + ry * Math.sin(f2);
		var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	}
	var t = Math.tan((f2 - f1) / 4);
	var hx = 4 / 3 * rx * t;
	var hy = 4 / 3 * ry * t;
	var curve = [
		2 * x1 - (x1 + hx * Math.sin(f1)),
		2 * y1 - (y1 - hy * Math.cos(f1)),
		x2 + hx * Math.sin(f2),
		y2 - hy * Math.cos(f2),
		x2,
		y2
	];
	if (recursive) return curve
	if (res) curve = curve.concat(res);
	for (var i = 0; i < curve.length;) {
		var rot = rotate(curve[i], curve[i+1], angle);
		curve[i++] = rot.x;
		curve[i++] = rot.y;
	}
	return curve
}

function rotate(x, y, rad){
	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	}
}

function radians(degress){
	return degress * (π / 180)
}

var vec2Copy = function vec2Copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out
};

var bezier = adaptiveBezierCurve;
var abs = absSvgPath;
var norm = normalizeSvgPath;
var copy = vec2Copy;

function set(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out
}

var tmp1 = [0,0],
    tmp2 = [0,0],
    tmp3 = [0,0];

function bezierTo(points, scale, start, seg) {
    bezier(start, 
        set(tmp1, seg[1], seg[2]), 
        set(tmp2, seg[3], seg[4]),
        set(tmp3, seg[5], seg[6]), scale, points);
}

var svgPathContours = function contours(svg, scale) {
    var paths = [];

    var points = [];
    var pen = [0, 0];
    norm(abs(svg)).forEach(function(segment, i, self) {
        if (segment[0] === 'M') {
            copy(pen, segment.slice(1));
            if (points.length>0) {
                paths.push(points);
                points = [];
            }
        } else if (segment[0] === 'C') {
            bezierTo(points, scale, pen, segment);
            set(pen, segment[5], segment[6]);
        } else {
            throw new Error('illegal type in SVG: '+segment[0])
        }
    });
    if (points.length>0)
        paths.push(points);
    return paths
};

var contours = /*@__PURE__*/getDefaultExportFromCjs(svgPathContours);

/**
 * Create geometry for classic connection.
 * Can be used in `customize` option.
 * @param path SVG path
 * @param width Connection width
 * @returns Connection geometry
 */
// eslint-disable-next-line max-statements
function createClassicConnectionGeometry(path, width) {
  var segments = contours(parse$1(path));
  var points = segments.map(function (segment) {
    return segment.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        x = _ref2[0],
        y = _ref2[1];
      return {
        x: x,
        y: y
      };
    });
  }).flat();
  var geometry = new PlaneGeometry(100, 10, points.length - 1, 1);
  for (var i = 0; i < points.length; i++) {
    var normal = new Vector2(0, width / 2);
    var point = new Vector2(points[i].x, points[i].y);
    if (i > 0 && i < points.length - 1) {
      var prevPoint = new Vector2(points[i - 1].x, points[i - 1].y);
      var nextPoint = new Vector2(points[i + 1].x, points[i + 1].y);
      var vectorBetweenPoints = nextPoint.clone().sub(prevPoint);
      var normalBetweenPoints = new Vector2(-vectorBetweenPoints.y, vectorBetweenPoints.x).clone().normalize();
      normal.set(normalBetweenPoints.x, normalBetweenPoints.y).multiplyScalar(width / 2);
    }
    geometry.attributes.position.setX(i, point.x + normal.x);
    geometry.attributes.position.setY(i, point.y + normal.y);
    geometry.attributes.position.setX(i + points.length, point.x - normal.x);
    geometry.attributes.position.setY(i + points.length, point.y - normal.y);
  }
  return geometry;
}

/**
 * Options for node form generator
 */

/**
 * Form generator for embedding connections into 3D scene.
 * @param scope Area3DPlugin instance
 * @param props Options for connection form generator
 */
function connection(scope, props) {
  var renderScope = scope;
  var area = renderScope.parentScope(Area3DPlugin);
  // const editor = area.parentScope<NodeEditor<S>>(NodeEditor)

  renderScope.addPipe(function (context) {
    if (!context || _typeof(context) !== 'object' || !('type' in context)) return context;
    if (context.type === 'connectionpath') {
      var id = context.data.payload.id;
      var view = area.connectionViews.get(id);
      if (view) {
        var _path = context.data.path || classicConnectionPath(context.data.points, 0.3);
        var geometry = props !== null && props !== void 0 && props.customize ? props.customize(_path) : createClassicConnectionGeometry(_path, 4.6);
        if (geometry) {
          area.area.content.updateGeometry(view.element, geometry);
        }
      }
    }
    return context;
  });
}

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let gpuType = - 1;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		if ( gpuType === - 1 ) gpuType = attribute.gpuType;
		if ( gpuType !== attribute.gpuType ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	const result = new BufferAttribute( array, itemSize, normalized );
	if ( gpuType !== undefined ) {

		result.gpuType = gpuType;

	}

	return result;

}

/**
 * Classic node geometry parameters
 */

/**
 * Create classic node geometry
 * @param size Node size
 * @param params Geometry parameters
 * @returns Node geometry
 */ // eslint-disable-next-line max-statements
function createClassicNodeGeometry(size, params) {
  var _ref = params || {},
    _ref$borderRadius = _ref.borderRadius,
    borderRadius = _ref$borderRadius === void 0 ? 10 : _ref$borderRadius,
    _ref$inputsOffset = _ref.inputsOffset,
    inputsOffset = _ref$inputsOffset === void 0 ? 15.5 : _ref$inputsOffset,
    _ref$outputsOffset = _ref.outputsOffset,
    outputsOffset = _ref$outputsOffset === void 0 ? 44.5 : _ref$outputsOffset,
    _ref$socketRadius = _ref.socketRadius,
    socketRadius = _ref$socketRadius === void 0 ? 12.3 : _ref$socketRadius,
    _ref$socketMargin = _ref.socketMargin,
    socketMargin = _ref$socketMargin === void 0 ? 11.5 : _ref$socketMargin;
  var fixWidth = size.width - 1; // hide border artifact
  var fixHeight = size.height - 1; // hide border artifact
  var shape = getRoundedShape(fixWidth, fixHeight, borderRadius * 1.05);
  var geometry = new ShapeGeometry(shape);
  var circle = new CircleGeometry(socketRadius, 16);
  var extra = [];
  if ('inputs' in size) {
    var inputs = Object.entries(size.inputs).length;
    for (var index = 0; index < inputs; index++) {
      var geom = circle.clone();
      var x = 1.5;
      var y = size.height - socketRadius - inputsOffset - (socketRadius * 2 + socketMargin) * index;
      geom.translate(x, y, 0);
      extra.push(geom);
    }
  }
  if ('outputs' in size) {
    var outputs = Object.entries(size.outputs).length;
    for (var _index = 0; _index < outputs; _index++) {
      var _geom = circle.clone();
      var _x = size.width - 1.5;
      var _y = socketRadius + outputsOffset + (socketRadius * 2 + socketMargin) * _index;
      _geom.translate(_x, _y, 0);
      extra.push(_geom);
    }
  }
  return mergeGeometries([].concat(extra, [geometry]));
}

/**
 * Options for node form generator
 */

/**
 * Form generator for embedding nodes into 3D scene.
 * @param area Area3DPlugin instance
 * @param props Options for node form generator
 */
function node(area, props) {
  var editor = area.parentScope(NodeEditor);
  area.addPipe(function (context) {
    if (!context || _typeof(context) !== 'object' || !('type' in context)) return context;
    if (context.type === 'render' && context.data.type === 'node') {
      var id = context.data.payload.id;
      var currentNode = editor.getNode(id);
      var geometry = props !== null && props !== void 0 && props.customize ? props.customize(currentNode) : createClassicNodeGeometry(currentNode);
      area.area.content.updateGeometry(context.data.element, geometry);
    }
    return context;
  });
}

/**
 * Form generator for embedding rete-connection-reroute-plugin into 3D scene.
 * @param scope Area3DPlugin instance
 */
function reroute(scope) {
  if (!(scope instanceof Area3DPlugin)) throw new Error('');
  var area = scope;
  area.addPipe(function (context) {
    if (!context || _typeof(context) !== 'object' || !('type' in context)) return context;
    if (context.type === 'render' && context.data.type === 'reroute-pins') {
      var pinGeometry = new CircleGeometry(10, 16);
      var pins = context.data.data.pins.map(function (pin) {
        return pinGeometry.clone().translate(pin.position.x, pin.position.y, 0);
      });

      // eslint-disable-next-line no-undefined
      area.area.content.updateGeometry(context.data.element, pins.length ? mergeGeometries(pins) : undefined);
    }
    return context;
  });
}

/**
 * Group of functions to replicate forms.
 * This extension provides a functions for generating geometry that replicates the form of HTML elements embedded in the scene.
 * @module Extensions/Forms
 */

var index$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	comment: comment,
	connection: connection,
	createClassicConnectionGeometry: createClassicConnectionGeometry,
	createClassicNodeGeometry: createClassicNodeGeometry,
	node: node,
	reroute: reroute
});

/**
 * Bounding box
 */
var min = function min(arr) {
  return arr.length === 0 ? 0 : Math.min.apply(Math, _toConsumableArray(arr));
};
var max = function max(arr) {
  return arr.length === 0 ? 0 : Math.max.apply(Math, _toConsumableArray(arr));
};
function getBoundingBox$1(rects) {
  var left = min(rects.map(function (rect) {
    return rect.position.x;
  }));
  var top = min(rects.map(function (rect) {
    return rect.position.y;
  }));
  var right = max(rects.map(function (rect) {
    return rect.position.x + rect.width;
  }));
  var bottom = max(rects.map(function (rect) {
    return rect.position.y + rect.height;
  }));
  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    width: Math.abs(left - right),
    height: Math.abs(top - bottom),
    center: {
      x: (left + right) / 2,
      y: (top + bottom) / 2
    }
  };
}

function getNodesRect(nodes, views) {
  return nodes.map(function (node) {
    return {
      view: views.get(node.id),
      node: node
    };
  }).filter(function (item) {
    return item.view;
  }).map(function (_ref) {
    var view = _ref.view,
      node = _ref.node;
    var width = node.width,
      height = node.height;
    if (typeof width !== 'undefined' && typeof height !== 'undefined') {
      return {
        position: view.position,
        width: width,
        height: height
      };
    }
    return {
      position: view.position,
      width: view.element.clientWidth,
      height: view.element.clientHeight
    };
  });
}

function getBoundingBox(plugin, nodes) {
  var editor = plugin.parentScope(NodeEditor);
  var list = nodes.map(function (node) {
    return _typeof(node) === 'object' ? node : editor.getNode(node);
  });
  var rects = getNodesRect(list, plugin.nodeViews);
  return getBoundingBox$1(rects);
}

/**
 * Parameters for `zoomAt` extension
 */

/**
 * Move the camera to look at the given nodes
 * @param area The 3D area plugin
 * @param nodes The nodes to look at
 * @param params The lookAt parameters
 * @example Area3DExtensions.lookAt(area, [node1, node2])
 * @example Area3DExtensions.lookAt(area, [node1, node2], { scale: 0.8 })
 */
function lookAt(area, nodes, params) {
  var _ref = params || {},
    _ref$scale = _ref.scale,
    scale = _ref$scale === void 0 ? 0.9 : _ref$scale;
  var scene = area.area.scene;
  var camera = scene.camera,
    orbit = scene.orbit,
    canvases = scene.canvases;
  var canvas = canvases.get(area);
  var bbox = getBoundingBox(area, nodes);
  if (!canvas) throw new Error('cannot found canvas');
  var distance = getTargetDistance(camera, area.container, bbox, scale);
  var target = new Vector3(bbox.center.x, bbox.center.y, 0);
  var source = target.clone().add(new Vector3(0, 0, distance));
  canvas.localToWorld(target);
  canvas.localToWorld(source);
  camera.position.copy(source);
  orbit.target.copy(target);
  orbit.update();
}
function getTargetDistance(camera, container, size, scale) {
  var fov = camera.fov * (Math.PI / 180);
  var fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
  var dx = Math.abs(size.width / 2 / Math.tan(fovh / 2));
  var dy = Math.abs(size.height / 2 / Math.tan(fov / 2));
  var minDistance = Math.abs(container.clientHeight / 2 / Math.tan(fov / 2));
  var distance = Math.max(dx, dy, minDistance);
  return distance / scale;
}

/**
 * Area 3D extensions.
 * These extensions are specific to the 3D area and provide additional functionality, while many of rete-area-plugin's extensions are also available for this plugin.
 * @priority 7
 * @module Extensions
 */

var index = /*#__PURE__*/Object.freeze({
	__proto__: null,
	forms: index$1,
	animate: animate,
	lookAt: lookAt
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Signal types produced by Area3DPlugin instance
 * @priority 10
 */
/**
 * Plugin for embedding node editor into 3D scene.
 * @priority 9
 */
var Area3DPlugin = /*#__PURE__*/function (_BaseAreaPlugin) {
  _inherits(Area3DPlugin, _BaseAreaPlugin);
  var _super = _createSuper(Area3DPlugin);
  function Area3DPlugin(argument) {
    var _this;
    _classCallCheck(this, Area3DPlugin);
    _this = _super.call(this, 'area-3d');
    /**
     * Area instance, contains nodes, connections and other elements
     */
    _defineProperty(_assertThisInitialized(_this), "nodeViews", new Map());
    _defineProperty(_assertThisInitialized(_this), "connectionViews", new Map());
    _defineProperty(_assertThisInitialized(_this), "elements", new ElementsHolder());
    _defineProperty(_assertThisInitialized(_this), "onContextMenu", function (event) {
      _this.emit({
        type: 'contextmenu',
        data: {
          event: event,
          context: 'root'
        }
      });
    });
    _this.container = argument instanceof Area3DPlugin ? argument.container : argument;
    _this.container.style.overflow = 'hidden';
    _this.container.addEventListener('contextmenu', _this.onContextMenu);
    _this.area = new Area(_this.container, argument instanceof Area3DPlugin ? argument.area.scene : null, _assertThisInitialized(_this), {
      pointerDown: function pointerDown(position, event) {
        return _this.emit({
          type: 'pointerdown',
          data: {
            position: position,
            event: event
          }
        });
      },
      pointerMove: function pointerMove(position, event) {
        return _this.emit({
          type: 'pointermove',
          data: {
            position: position,
            event: event
          }
        });
      },
      pointerUp: function pointerUp(position, event) {
        return _this.emit({
          type: 'pointerup',
          data: {
            position: position,
            event: event
          }
        });
      },
      resize: function resize(event) {
        return _this.emit({
          type: 'resized',
          data: {
            event: event
          }
        });
      },
      transformed: function transformed(params) {
        return _this.emit({
          type: 'transformed',
          data: params
        });
      },
      reordered: function reordered(element) {
        return _this.emit({
          type: 'reordered',
          data: {
            element: element
          }
        });
      }
    }, {
      transform: function transform(params) {
        return _this.emit({
          type: 'transform',
          data: params
        });
      }
    });
    _this.area.scene.addCanvasFor(_assertThisInitialized(_this));
    return _this;
  }

  /**
   * Share the 3D scene with multiple instances of Area3DPlugin
   * @returns new instance of Area3DPlugin
   */
  _createClass(Area3DPlugin, [{
    key: "share",
    value: function share() {
      return new Area3DPlugin(this);
    }
  }, {
    key: "setParent",
    value: function setParent(scope) {
      var _this2 = this;
      _get(_getPrototypeOf(Area3DPlugin.prototype), "setParent", this).call(this, scope);
      this.addPipe(function (context) {
        if (!context || !(_typeof(context) === 'object' && 'type' in context)) return context;
        if (context.type === 'nodecreated') {
          _this2.addNodeView(context.data);
        }
        if (context.type === 'noderemoved') {
          _this2.removeNodeView(context.data.id);
        }
        if (context.type === 'connectioncreated') {
          _this2.addConnectionView(context.data);
        }
        if (context.type === 'connectionremoved') {
          _this2.removeConnectionView(context.data.id);
        }
        if (context.type === 'render') {
          _this2.elements.set(context.data);
        }
        if (context.type === 'unmount') {
          _this2.elements["delete"](context.data.element);
        }
        return context;
      });
    }
  }, {
    key: "addNodeView",
    value: function addNodeView(node) {
      var _this3 = this;
      var id = node.id;
      var view = new NodeView({
        picked: function picked() {
          return _this3.emit({
            type: 'nodepicked',
            data: {
              id: id
            }
          });
        },
        translated: function translated(data) {
          return _this3.emit({
            type: 'nodetranslated',
            data: _objectSpread({
              id: id
            }, data)
          });
        },
        dragged: function dragged() {
          return _this3.emit({
            type: 'nodedragged',
            data: node
          });
        },
        contextmenu: function contextmenu(event) {
          return _this3.emit({
            type: 'contextmenu',
            data: {
              event: event,
              context: node
            }
          });
        },
        resized: function resized(_ref) {
          var size = _ref.size;
          return _this3.emit({
            type: 'noderesized',
            data: {
              id: node.id,
              size: size
            }
          });
        }
      }, {
        translate: function translate(data) {
          return _this3.emit({
            type: 'nodetranslate',
            data: _objectSpread({
              id: id
            }, data)
          });
        },
        resize: function resize(_ref2) {
          var size = _ref2.size;
          return _this3.emit({
            type: 'noderesize',
            data: {
              id: node.id,
              size: size
            }
          });
        }
      });
      this.nodeViews.set(id, view);
      this.area.content.add(view.element, view.object);
      this.emit({
        type: 'render',
        data: {
          element: view.element,
          type: 'node',
          payload: node
        }
      });
      return view;
    }
  }, {
    key: "removeNodeView",
    value: function removeNodeView(id) {
      var view = this.nodeViews.get(id);
      if (view) {
        this.emit({
          type: 'unmount',
          data: {
            element: view.element
          }
        });
        this.nodeViews["delete"](id);
        this.area.content.remove(view.element);
      }
    }
  }, {
    key: "addConnectionView",
    value: function addConnectionView(connection) {
      var _this4 = this;
      var view = new ConnectionView({
        contextmenu: function contextmenu(event) {
          return _this4.emit({
            type: 'contextmenu',
            data: {
              event: event,
              context: connection
            }
          });
        }
      });
      this.connectionViews.set(connection.id, view);
      this.area.content.add(view.element, view.object);
      this.emit({
        type: 'render',
        data: {
          element: view.element,
          type: 'connection',
          payload: connection
        }
      });
      return view;
    }
  }, {
    key: "removeConnectionView",
    value: function removeConnectionView(id) {
      var view = this.connectionViews.get(id);
      if (view) {
        this.emit({
          type: 'unmount',
          data: {
            element: view.element
          }
        });
        this.connectionViews["delete"](id);
        this.area.content.remove(view.element);
      }
    }

    /**
     * Translate node to position
     * @param id Node id
     * @param position Position
     */
  }, {
    key: "translate",
    value: function () {
      var _translate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id, _ref3) {
        var x, y, view;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              x = _ref3.x, y = _ref3.y;
              view = this.nodeViews.get(id);
              if (!view) {
                _context.next = 6;
                break;
              }
              _context.next = 5;
              return view.translate(x, y);
            case 5:
              return _context.abrupt("return", _context.sent);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function translate(_x, _x2) {
        return _translate.apply(this, arguments);
      }
      return translate;
    }()
    /**
     * Resize node
     * @param id Node id
     * @param width Desired width
     * @param height Desired height
     */
  }, {
    key: "resize",
    value: function () {
      var _resize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id, width, height) {
        var view;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              view = this.nodeViews.get(id);
              if (!view) {
                _context2.next = 5;
                break;
              }
              _context2.next = 4;
              return view.resize(width, height);
            case 4:
              return _context2.abrupt("return", _context2.sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function resize(_x3, _x4, _x5) {
        return _resize.apply(this, arguments);
      }
      return resize;
    }()
    /**
     * Force update rendered element by id (node, connection, etc.)
     * @param type Element type
     * @param id Element id
     * @emits render
     */
  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(type, id) {
        var data;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              data = this.elements.get(type, id);
              if (!data) {
                _context3.next = 4;
                break;
              }
              _context3.next = 4;
              return this.emit({
                type: 'render',
                data: data
              });
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function update(_x6, _x7) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
    /**
     * Destroy all views and remove all event listeners
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var _this5 = this;
      this.container.removeEventListener('contextmenu', this.onContextMenu);
      Array.from(this.connectionViews.keys()).forEach(function (id) {
        return _this5.removeConnectionView(id);
      });
      Array.from(this.nodeViews.keys()).forEach(function (id) {
        return _this5.removeNodeView(id);
      });
      this.area.destroy();
    }
  }]);
  return Area3DPlugin;
}(BaseAreaPlugin);

export { index as Area3DExtensions, Area3DPlugin };
//# sourceMappingURL=area3-d-plugin.esm.js.map
