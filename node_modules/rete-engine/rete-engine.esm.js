/*!
* rete-engine v2.0.0
* (c) 2024 Vitaliy Stoliarov
* Released under the MIT license.
* */
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _get from '@babel/runtime/helpers/get';
import _inherits from '@babel/runtime/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';
import { NodeEditor, Scope } from 'rete';
import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';
import _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';

/**
 * ControlFlowNodeSetup is a set of functions that define how to execute a node.
 */

/**
 * ControlFlow is a class that allows to execute nodes in a graph using Control flow approach.
 * @priority 7
 */
var ControlFlow = /*#__PURE__*/function () {
  /**
   * @param editor NodeEditor instance
   */
  function ControlFlow(editor) {
    _classCallCheck(this, ControlFlow);
    _defineProperty(this, "setups", new Map());
    this.editor = editor;
  }

  /**
   * Adds the node to the control flow.
   * @param node Node instance
   * @param setup Set of functions that define how to execute the node
   */
  _createClass(ControlFlow, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error('already processed');
      }
      this.setups.set(node.id, setup);
    }

    /**
     * Removes the node from the control flow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }

    /**
     * Execute the node and its successors (in case `forward` is called for some output).
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      var _this = this;
      var setup = this.setups.get(nodeId);
      if (!setup) throw new Error('node is not initialized');
      var inputKeys = setup.inputs();
      if (input && !inputKeys.includes(input)) throw new Error('inputs don\'t have a key');
      setup.execute(input, function (output) {
        var outputKeys = setup.outputs();
        if (!outputKeys.includes(output)) throw new Error('outputs don\'t have a key');
        var cons = _this.editor.getConnections().filter(function (c) {
          return c.source === nodeId && c.sourceOutput === output;
        });
        cons.forEach(function (con) {
          _this.execute(con.target, con.targetInput);
        });
      });
    }
  }]);
  return ControlFlow;
}();

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * ControlFlowEngine is a plugin that integrates ControlFlow with NodeEditor making it easy to use
 * @priority 9
 * @listens nodecreated
 * @listens noderemoved
 */
var ControlFlowEngine = /*#__PURE__*/function (_Scope) {
  _inherits(ControlFlowEngine, _Scope);
  var _super = _createSuper$2(ControlFlowEngine);
  /**
   * @param configure Allows to specify which inputs and outputs are part of the control flow
   */
  function ControlFlowEngine(configure) {
    var _this;
    _classCallCheck(this, ControlFlowEngine);
    _this = _super.call(this, 'control-flow-engine');
    _this.configure = configure;
    _this.addPipe(function (context) {
      if (context.type === 'nodecreated') {
        _this.add(context.data);
      }
      if (context.type === 'noderemoved') {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _createClass(ControlFlowEngine, [{
    key: "setParent",
    value: function setParent(scope) {
      _get(_getPrototypeOf(ControlFlowEngine.prototype), "setParent", this).call(this, scope);
      this.editor = this.parentScope(NodeEditor);
      this.controlflow = new ControlFlow(this.editor);
    }
  }, {
    key: "add",
    value: function add(node) {
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.controlflow.add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        execute: function execute(input, forward) {
          node.execute(String(input), forward);
        }
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.controlflow.remove(node.id);
    }

    /**
     * Trigger execution starting from the specified node.
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
  }, {
    key: "execute",
    value: function execute(nodeId, input) {
      this.controlflow.execute(nodeId, input);
    }
  }]);
  return ControlFlowEngine;
}(Scope);

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * DataflowNodeSetup is a set of functions that define how to process a node.
 */

/**
 * Dataflow is a class that allows to process nodes in a graph using Dataflow approach.
 * @priority 8
 */
var Dataflow = /*#__PURE__*/function () {
  /**
   * @param editor NodeEditor instance
   */
  function Dataflow(editor) {
    _classCallCheck(this, Dataflow);
    _defineProperty(this, "setups", new Map());
    this.editor = editor;
  }

  /**
   * Adds the node to the dataflow.
   * @param node Node instance
   * @param setup Set of functions that define how to process the node
   */
  _createClass(Dataflow, [{
    key: "add",
    value: function add(node, setup) {
      var affected = this.setups.get(node.id);
      if (affected) {
        throw new Error('already processed');
      }
      this.setups.set(node.id, setup);
    }

    /**
     * Removes the node from the dataflow.
     * @param nodeId Node id
     */
  }, {
    key: "remove",
    value: function remove(nodeId) {
      this.setups["delete"](nodeId);
    }

    /**
     * Fetches inputs of the node.
     * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).
     * @param nodeId Node id
     * @returns Object with inputs
     */
  }, {
    key: "fetchInputs",
    value: function () {
      var _fetchInputs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nodeId) {
        var _this = this;
        var result, inputKeys, cons, inputs, consWithSourceData, _iterator, _step, _step$value, c, sourceData, previous;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              result = this.setups.get(nodeId);
              if (result) {
                _context2.next = 3;
                break;
              }
              throw new Error('node is not initialized');
            case 3:
              inputKeys = result.inputs();
              cons = this.editor.getConnections().filter(function (c) {
                return c.target === nodeId && inputKeys.includes(c.targetInput);
              });
              inputs = {};
              _context2.next = 8;
              return Promise.all(cons.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(c) {
                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.t0 = c;
                        _context.next = 3;
                        return _this.fetch(c.source);
                      case 3:
                        _context.t1 = _context.sent;
                        return _context.abrupt("return", {
                          c: _context.t0,
                          sourceData: _context.t1
                        });
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function (_x2) {
                  return _ref.apply(this, arguments);
                };
              }()));
            case 8:
              consWithSourceData = _context2.sent;
              _iterator = _createForOfIteratorHelper(consWithSourceData);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _step$value = _step.value, c = _step$value.c, sourceData = _step$value.sourceData;
                  previous = inputs[c.targetInput] ? inputs[c.targetInput] : [];
                  inputs[c.targetInput] = [].concat(_toConsumableArray(previous), [sourceData[c.sourceOutput]]);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context2.abrupt("return", inputs);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function fetchInputs(_x) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches outputs of the node.
     * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.
     * @param nodeId Node id
     * @returns Object with outputs
     */
  }, {
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(nodeId) {
        var _this2 = this;
        var result, outputKeys, data, returningKeys;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              result = this.setups.get(nodeId);
              if (result) {
                _context3.next = 3;
                break;
              }
              throw new Error('node is not initialized');
            case 3:
              outputKeys = result.outputs();
              _context3.next = 6;
              return result.data(function () {
                return _this2.fetchInputs(nodeId);
              });
            case 6:
              data = _context3.sent;
              returningKeys = Object.keys(data);
              if (outputKeys.every(function (key) {
                return returningKeys.includes(key);
              })) {
                _context3.next = 10;
                break;
              }
              throw new Error("dataflow node \"".concat(nodeId, "\" doesn't return all of required properties. Expected \"").concat(outputKeys.join('", "'), "\". Got \"").concat(returningKeys.join('", "'), "\""));
            case 10:
              return _context3.abrupt("return", data);
            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
  }]);
  return Dataflow;
}();

var Cache = /*#__PURE__*/function () {
  function Cache(onDelete) {
    _classCallCheck(this, Cache);
    _defineProperty(this, "cache", new Map());
    this.onDelete = onDelete;
  }
  _createClass(Cache, [{
    key: "get",
    value: function get(key) {
      return this.cache.get(key);
    }
  }, {
    key: "add",
    value: function add(key, data) {
      if (this.cache.has(key)) throw new Error('cache already exists');
      this.cache.set(key, data);
    }
  }, {
    key: "patch",
    value: function patch(key, data) {
      this.cache.set(key, data);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var item = this.cache.get(key);
      this.cache["delete"](key);
      this.onDelete && this.onDelete(item);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this = this;
      Array.from(this.cache.keys()).forEach(function (item) {
        _this["delete"](item);
      });
    }
  }]);
  return Cache;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Cancelled exception. Thrown when `reset` is called while fetching data.
 */
var Cancelled = /*#__PURE__*/function (_Error) {
  _inherits(Cancelled, _Error);
  var _super = _createSuper$1(Cancelled);
  function Cancelled() {
    _classCallCheck(this, Cancelled);
    return _super.call(this, 'cancelled');
  }
  return _createClass(Cancelled);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function createCancellblePromise() {
  var cancelled = false;
  function commit(value) {
    if (cancelled) {
      throw new Cancelled();
    }
    return value;
  }

  // eslint-disable-next-line init-declarations
  var reject;
  var promise = new Promise(function (res, rej) {
    reject = rej;
    res();
  });
  for (var _len = arguments.length, sequence = new Array(_len), _key = 0; _key < _len; _key++) {
    sequence[_key] = arguments[_key];
  }
  var n = sequence.reduce(function (p, item) {
    var t = p.then(item).then(commit);
    return t;
  }, promise);
  n.cancel = function () {
    if (!cancelled) reject(new Cancelled());
    cancelled = true;
  };
  return n;
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * DataflowEngine is a plugin that integrates Dataflow with NodeEditor making it easy to use.
 * Additionally, it provides a cache for the data of each node in order to avoid recurring calculations.
 * @priority 10
 * @listens nodecreated
 * @listens noderemoved
 */
var DataflowEngine = /*#__PURE__*/function (_Scope) {
  _inherits(DataflowEngine, _Scope);
  var _super = _createSuper(DataflowEngine);
  function DataflowEngine(configure) {
    var _this;
    _classCallCheck(this, DataflowEngine);
    _this = _super.call(this, 'dataflow-engine');
    _defineProperty(_assertThisInitialized(_this), "cache", new Cache(function (data) {
      return (data === null || data === void 0 ? void 0 : data.cancel) && data.cancel();
    }));
    _this.configure = configure;
    _this.addPipe(function (context) {
      if (context.type === 'nodecreated') {
        _this.add(context.data);
      }
      if (context.type === 'noderemoved') {
        _this.remove(context.data);
      }
      return context;
    });
    return _this;
  }
  _createClass(DataflowEngine, [{
    key: "setParent",
    value: function setParent(scope) {
      _get(_getPrototypeOf(DataflowEngine.prototype), "setParent", this).call(this, scope);
      this.editor = this.parentScope(NodeEditor);
      this.dataflow = new Dataflow(this.editor);
    }
  }, {
    key: "getDataflow",
    value: function getDataflow() {
      if (!this.dataflow) throw new Error("DataflowEngine isn't attached to NodeEditor");
      return this.dataflow;
    }
  }, {
    key: "add",
    value: function add(node) {
      var _this2 = this;
      var options = this.configure ? this.configure(node) : {
        inputs: function inputs() {
          return Object.keys(node.inputs);
        },
        outputs: function outputs() {
          return Object.keys(node.outputs);
        }
      };
      this.getDataflow().add(node, {
        inputs: options.inputs,
        outputs: options.outputs,
        data: function () {
          var _data = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(fetchInputs) {
            var cache, cancellable;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  cache = _this2.cache.get(node.id);
                  if (!cache) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", cache);
                case 3:
                  cancellable = createCancellblePromise(function () {
                    return fetchInputs();
                  }, function (inputs) {
                    return node.data(inputs);
                  });
                  _this2.cache.add(node.id, cancellable);
                  return _context.abrupt("return", cancellable);
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function data(_x) {
            return _data.apply(this, arguments);
          }
          return data;
        }()
      });
    }
  }, {
    key: "remove",
    value: function remove(node) {
      this.getDataflow().remove(node.id);
    }

    /**
     * Resets the cache of the node and all its predecessors.
     * @param nodeId Node id to reset. If not specified, all nodes will be reset.
     */
  }, {
    key: "reset",
    value: function reset(nodeId) {
      var _this3 = this;
      if (nodeId) {
        var setup = this.getDataflow().setups.get(nodeId);
        if (!setup) throw 'setup';
        var outputKeys = setup.outputs();
        this.cache["delete"](nodeId);
        this.editor.getConnections().filter(function (c) {
          return c.source === nodeId && outputKeys.includes(c.sourceOutput);
        }).forEach(function (c) {
          return _this3.reset(c.target);
        });
      } else {
        this.cache.clear();
      }
    }

    /**
     * Fetches input data for the node by fetching data for all its predecessors recursively.
     * @param nodeId Node id to fetch input data for
     * @throws `Cancelled when `reset` is called while fetching data
     */
  }, {
    key: "fetchInputs",
    value: function () {
      var _fetchInputs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nodeId) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.getDataflow().fetchInputs(nodeId));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function fetchInputs(_x2) {
        return _fetchInputs.apply(this, arguments);
      }
      return fetchInputs;
    }()
    /**
     * Fetches output data of the node
     * @param nodeId Node id to fetch data from
     * @throws `Cancelled` when `reset` is called while fetching data
     */
  }, {
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(nodeId) {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.getDataflow().fetch(nodeId));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
  }]);
  return DataflowEngine;
}(Scope);

export { Cancelled, ControlFlow, ControlFlowEngine, Dataflow, DataflowEngine, createCancellblePromise };
//# sourceMappingURL=rete-engine.esm.js.map
