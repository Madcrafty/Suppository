import { NodeEditor, NodeId } from 'rete';
import { ClassicScheme } from './types';
/**
 * ControlFlowNodeSetup is a set of functions that define how to execute a node.
 */
export declare type ControlFlowNodeSetup<T extends ClassicScheme['Node'], I extends (keyof T['inputs'])[] = string[], O extends (keyof T['outputs'])[] = string[]> = {
    /** Specifies the inputs which are part of the control flow */
    inputs: () => I;
    /** Specifies the outputs which are part of the control flow */
    outputs: () => O;
    /** Called when the node received control from the previous node */
    execute(input: I[number], forward: (output: O[number]) => any): any;
};
/**
 * ControlFlow is a class that allows to execute nodes in a graph using Control flow approach.
 * @priority 7
 */
export declare class ControlFlow<Schemes extends ClassicScheme> {
    private editor;
    setups: Map<string, ControlFlowNodeSetup<any, any, any>>;
    /**
     * @param editor NodeEditor instance
     */
    constructor(editor: NodeEditor<Schemes>);
    /**
     * Adds the node to the control flow.
     * @param node Node instance
     * @param setup Set of functions that define how to execute the node
     */
    add<T extends Schemes['Node']>(node: T, setup: ControlFlowNodeSetup<T, (keyof T['inputs'])[], (keyof T['outputs'])[]>): void;
    /**
     * Removes the node from the control flow.
     * @param nodeId Node id
     */
    remove(nodeId: NodeId): void;
    /**
     * Execute the node and its successors (in case `forward` is called for some output).
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
    execute(nodeId: NodeId, input?: string): void;
}
//# sourceMappingURL=control-flow.d.ts.map