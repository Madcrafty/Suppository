import { GetSchemes, NodeEditor, NodeId, Root, Scope } from 'rete';
import { ControlFlow } from './control-flow';
import { ClassicScheme } from './types';
export declare type ControlFlowEngineScheme = GetSchemes<ClassicScheme['Node'] & {
    execute(input: string, forward: (output: string) => void): void;
}, ClassicScheme['Connection']>;
declare type Configure<Schemes extends ControlFlowEngineScheme> = (node: Schemes['Node']) => ({
    inputs: () => string[];
    outputs: () => string[];
});
/**
 * ControlFlowEngine is a plugin that integrates ControlFlow with NodeEditor making it easy to use
 * @priority 9
 * @listens nodecreated
 * @listens noderemoved
 */
export declare class ControlFlowEngine<Schemes extends ControlFlowEngineScheme> extends Scope<never, [Root<Schemes>]> {
    private configure?;
    editor: NodeEditor<Schemes>;
    controlflow: ControlFlow<Schemes>;
    /**
     * @param configure Allows to specify which inputs and outputs are part of the control flow
     */
    constructor(configure?: Configure<Schemes> | undefined);
    setParent(scope: Scope<Root<Schemes>>): void;
    private add;
    private remove;
    /**
     * Trigger execution starting from the specified node.
     * @param nodeId Node id
     * @param input Input key that will be considered as the initiator of the execution
     */
    execute(nodeId: NodeId, input?: string): void;
}
export {};
//# sourceMappingURL=control-flow-engine.d.ts.map