{"version":3,"file":"rete-engine.min.js","sources":["src/control-flow.ts","src/control-flow-engine.ts","src/dataflow.ts","src/utils/cache.ts","src/utils/cancellable.ts","src/dataflow-engine.ts"],"sourcesContent":["import { NodeEditor, NodeId } from 'rete'\n\nimport { ClassicScheme } from './types'\n\n/**\n * ControlFlowNodeSetup is a set of functions that define how to execute a node.\n */\nexport type ControlFlowNodeSetup<T extends ClassicScheme['Node'], I extends (keyof T['inputs'])[] = string[], O extends (keyof T['outputs'])[] = string[]> = {\n  /** Specifies the inputs which are part of the control flow */\n  inputs: () => I\n  /** Specifies the outputs which are part of the control flow */\n  outputs: () => O\n  /** Called when the node received control from the previous node */\n  execute(input: I[number], forward: (output: O[number]) => any): any\n}\n\n/**\n * ControlFlow is a class that allows to execute nodes in a graph using Control flow approach.\n * @priority 7\n */\nexport class ControlFlow<Schemes extends ClassicScheme> {\n  setups = new Map<NodeId, ControlFlowNodeSetup<any, any, any>>()\n\n  /**\n   * @param editor NodeEditor instance\n   */\n  constructor(private editor: NodeEditor<Schemes>) { }\n\n  /**\n   * Adds the node to the control flow.\n   * @param node Node instance\n   * @param setup Set of functions that define how to execute the node\n   */\n  public add<T extends Schemes['Node']>(node: T, setup: ControlFlowNodeSetup<T, (keyof T['inputs'])[], (keyof T['outputs'])[]>) {\n    const affected = this.setups.get(node.id)\n\n    if (affected) {\n      throw new Error('already processed')\n    }\n    this.setups.set(node.id, setup)\n  }\n\n  /**\n   * Removes the node from the control flow.\n   * @param nodeId Node id\n   */\n  public remove(nodeId: NodeId) {\n    this.setups.delete(nodeId)\n  }\n\n  /**\n   * Execute the node and its successors (in case `forward` is called for some output).\n   * @param nodeId Node id\n   * @param input Input key that will be considered as the initiator of the execution\n   */\n  public execute(nodeId: NodeId, input?: string) {\n    const setup = this.setups.get(nodeId)\n\n    if (!setup) throw new Error('node is not initialized')\n    const inputKeys = setup.inputs()\n\n    if (input && !inputKeys.includes(input)) throw new Error('inputs don\\'t have a key')\n\n    setup.execute(input, (output) => {\n      const outputKeys = setup.outputs()\n\n      if (!outputKeys.includes(output)) throw new Error('outputs don\\'t have a key')\n\n      const cons = this.editor.getConnections().filter(c => {\n        return c.source === nodeId && c.sourceOutput === output\n      })\n\n      cons.forEach(con => {\n        this.execute(con.target, con.targetInput)\n      })\n    })\n  }\n}\n","import { GetSchemes, NodeEditor, NodeId, Root, Scope } from 'rete'\n\nimport { ControlFlow } from './control-flow'\nimport { ClassicScheme } from './types'\n\nexport type ControlFlowEngineScheme = GetSchemes<\n  ClassicScheme['Node'] & { execute(input: string, forward: (output: string) => void): void },\n  ClassicScheme['Connection']\n>\n\ntype Configure<Schemes extends ControlFlowEngineScheme> = (node: Schemes['Node']) => ({\n  inputs: () => string[]\n  outputs: () => string[]\n})\n\n/**\n * ControlFlowEngine is a plugin that integrates ControlFlow with NodeEditor making it easy to use\n * @priority 9\n * @listens nodecreated\n * @listens noderemoved\n */\nexport class ControlFlowEngine<Schemes extends ControlFlowEngineScheme> extends Scope<never, [Root<Schemes>]> {\n  editor!: NodeEditor<Schemes>\n  controlflow!: ControlFlow<Schemes>\n\n  /**\n   * @param configure Allows to specify which inputs and outputs are part of the control flow\n   */\n  constructor(private configure?: Configure<Schemes>) {\n    super('control-flow-engine')\n\n    this.addPipe(context => {\n      if (context.type === 'nodecreated') {\n        this.add(context.data)\n      }\n      if (context.type === 'noderemoved') {\n        this.remove(context.data)\n      }\n      return context\n    })\n  }\n\n  setParent(scope: Scope<Root<Schemes>>): void {\n    super.setParent(scope)\n\n    this.editor = this.parentScope<NodeEditor<Schemes>>(NodeEditor)\n    this.controlflow = new ControlFlow(this.editor)\n  }\n\n  private add(node: Schemes['Node']) {\n    const options = this.configure\n      ? this.configure(node)\n      : { inputs: () => Object.keys(node.inputs), outputs: () => Object.keys(node.outputs) }\n\n    this.controlflow.add(node, {\n      inputs: options.inputs,\n      outputs: options.outputs,\n      execute: (input, forward) => {\n        node.execute(String(input), forward)\n      }\n    })\n  }\n\n  private remove(node: Schemes['Node']) {\n    this.controlflow.remove(node.id)\n  }\n\n  /**\n   * Trigger execution starting from the specified node.\n   * @param nodeId Node id\n   * @param input Input key that will be considered as the initiator of the execution\n   */\n  public execute(nodeId: NodeId, input?: string) {\n    this.controlflow.execute(nodeId, input)\n  }\n}\n","import { NodeEditor, NodeId } from 'rete'\n\nimport { ClassicScheme } from './types'\n\n/**\n * DataflowNodeSetup is a set of functions that define how to process a node.\n */\nexport type DataflowNodeSetup<\n  T extends ClassicScheme['Node'],\n  I extends { [key in keyof T['inputs']]: any },\n  O extends { [key in keyof T['outputs']]: any }\n> = {\n  inputs: () => (keyof I)[]\n  outputs: () => (keyof O)[]\n  data(fetchInputs: () => Promise<{ [key in keyof I]: I[key][] }>): Promise<O> | O\n}\n\n/**\n * Dataflow is a class that allows to process nodes in a graph using Dataflow approach.\n * @priority 8\n */\nexport class Dataflow<Schemes extends ClassicScheme> {\n  setups = new Map<NodeId, DataflowNodeSetup<any, any, any>>()\n\n  /**\n   * @param editor NodeEditor instance\n   */\n  constructor(private editor: NodeEditor<Schemes>) { }\n\n  /**\n   * Adds the node to the dataflow.\n   * @param node Node instance\n   * @param setup Set of functions that define how to process the node\n   */\n  public add<T extends Schemes['Node']>(node: T, setup: DataflowNodeSetup<T, any, any>) {\n    const affected = this.setups.get(node.id)\n\n    if (affected) {\n      throw new Error('already processed')\n    }\n    this.setups.set(node.id, setup)\n  }\n\n  /**\n   * Removes the node from the dataflow.\n   * @param nodeId Node id\n   */\n  public remove(nodeId: NodeId) {\n    this.setups.delete(nodeId)\n  }\n\n  /**\n   * Fetches inputs of the node.\n   * Unlike `fetch` method, this method doesn't call `data` function of the specified node (but does call `data` for predecessor nodes recursively).\n   * @param nodeId Node id\n   * @returns Object with inputs\n   */\n  public async fetchInputs(nodeId: NodeId) {\n    const result = this.setups.get(nodeId)\n\n    if (!result) throw new Error('node is not initialized')\n\n    const inputKeys = result.inputs()\n\n    const cons = this.editor.getConnections().filter(c => {\n      return c.target === nodeId && inputKeys.includes(c.targetInput)\n    })\n\n    const inputs: Record<string, any> = {}\n    const consWithSourceData = await Promise.all(cons.map(async c => {\n      return {\n        c,\n        sourceData: await this.fetch(c.source)\n      }\n    }))\n\n    for (const { c, sourceData } of consWithSourceData) {\n      const previous = inputs[c.targetInput] ? inputs[c.targetInput] : []\n\n      inputs[c.targetInput] = [...previous, sourceData[c.sourceOutput]]\n    }\n\n    return inputs\n  }\n\n  /**\n   * Fetches outputs of the node.\n   * This method recursively calls `data` function of the predecessor nodes until receives all of the required inputs and calls `data` function of the specified node.\n   * @param nodeId Node id\n   * @returns Object with outputs\n   */\n  public async fetch(nodeId: NodeId): Promise<Record<string, any>> {\n    const result = this.setups.get(nodeId)\n\n    if (!result) throw new Error('node is not initialized')\n\n    const outputKeys = result.outputs()\n    const data = await result.data(() => this.fetchInputs(nodeId))\n\n    const returningKeys = Object.keys(data) as (string | number | symbol)[]\n\n    if (!outputKeys.every(key => returningKeys.includes(key))) {\n      throw new Error(`dataflow node \"${nodeId}\" doesn't return all of required properties. Expected \"${outputKeys.join('\", \"')}\". Got \"${returningKeys.join('\", \"')}\"`)\n    }\n\n    return data\n  }\n}\n","export class Cache<Key, T> {\n  cache = new Map<Key, T>()\n\n  constructor(private onDelete?: (item?: T) => void) {}\n\n  get(key: Key) {\n    return this.cache.get(key)\n  }\n\n  add(key: Key, data: T) {\n    if (this.cache.has(key)) throw new Error('cache already exists')\n\n    this.cache.set(key, data)\n  }\n\n  patch(key: Key, data: T) {\n    this.cache.set(key, data)\n  }\n\n  delete(key: Key) {\n    const item = this.cache.get(key)\n\n    this.cache.delete(key)\n    this.onDelete && this.onDelete(item)\n  }\n\n  clear() {\n    Array.from(this.cache.keys()).forEach(item => {\n      this.delete(item)\n    })\n  }\n}\n","/**\n * Cancelled exception. Thrown when `reset` is called while fetching data.\n */\nexport class Cancelled extends Error {\n  constructor() {\n    super('cancelled')\n  }\n}\n\nexport type Cancellable<T> = Promise<T> & { cancel?: () => void }\ntype S<A, B> = (data: A) => B | PromiseLike<B>\n\nfunction createCancellblePromise<A, B>(...sequence: [S<void, A>, S<A, B>]): Cancellable<B>\nfunction createCancellblePromise<A, B, C>(...sequence: [S<void, A>, S<A, B>, S<B, C>]): Cancellable<C>\nfunction createCancellblePromise(...sequence: S<any, any>[]): Cancellable<any> {\n  let cancelled = false\n\n  function commit<R>(value: R): R {\n    if (cancelled) {\n      throw new Cancelled()\n    }\n    return value\n  }\n\n  // eslint-disable-next-line init-declarations\n  let reject: (reason?: any) => void\n\n  const promise: Cancellable<void> = new Promise<void>((res, rej) => {\n    reject = rej\n    res()\n  })\n\n  const n = (sequence as S<any, any>[]).reduce((p, item) => {\n    const t = p.then(item as any).then(commit)\n\n    return t\n  }, promise)\n\n  n.cancel = () => {\n    if (!cancelled) reject(new Cancelled())\n    cancelled = true\n  }\n\n  return n\n}\n\nexport {\n  createCancellblePromise\n}\n","import { GetSchemes, NodeEditor, NodeId, Root, Scope } from 'rete'\n\nimport { Dataflow } from './dataflow'\nimport { ClassicScheme } from './types'\nimport { Cache } from './utils/cache'\nimport { Cancellable, createCancellblePromise } from './utils/cancellable'\n\nexport type DataflowNode = { data(inputs: Record<string, any>): Promise<Record<string, any>> | Record<string, any> }\nexport type DataflowEngineScheme = GetSchemes<\n  ClassicScheme['Node'] & DataflowNode,\n  ClassicScheme['Connection']\n>\n\ntype Configure<Schemes extends DataflowEngineScheme> = (node: Schemes['Node']) => ({\n  inputs: () => string[]\n  outputs: () => string[]\n})\n\n/**\n * DataflowEngine is a plugin that integrates Dataflow with NodeEditor making it easy to use.\n * Additionally, it provides a cache for the data of each node in order to avoid recurring calculations.\n * @priority 10\n * @listens nodecreated\n * @listens noderemoved\n */\nexport class DataflowEngine<Schemes extends DataflowEngineScheme> extends Scope<never, [Root<Schemes>]> {\n  editor!: NodeEditor<Schemes>\n  dataflow?: Dataflow<Schemes>\n  cache = new Cache<NodeId, Cancellable<Record<string, any>>>(data => data?.cancel && data.cancel())\n\n  constructor(private configure?: Configure<Schemes>) {\n    super('dataflow-engine')\n\n    this.addPipe(context => {\n      if (context.type === 'nodecreated') {\n        this.add(context.data)\n      }\n      if (context.type === 'noderemoved') {\n        this.remove(context.data)\n      }\n      return context\n    })\n  }\n\n  setParent(scope: Scope<Root<Schemes>>): void {\n    super.setParent(scope)\n\n    this.editor = this.parentScope<NodeEditor<Schemes>>(NodeEditor)\n    this.dataflow = new Dataflow(this.editor)\n  }\n\n  private getDataflow() {\n    if (!this.dataflow) throw new Error(`DataflowEngine isn't attached to NodeEditor`)\n    return this.dataflow\n  }\n\n  private add(node: Schemes['Node']) {\n    const options = this.configure\n      ? this.configure(node)\n      : { inputs: () => Object.keys(node.inputs), outputs: () => Object.keys(node.outputs) }\n\n    this.getDataflow().add(node, {\n      inputs: options.inputs,\n      outputs: options.outputs,\n      data: async (fetchInputs) => {\n        const cache = this.cache.get(node.id)\n\n        if (cache) return cache\n\n        const cancellable = createCancellblePromise(\n          () => fetchInputs(),\n          inputs => node.data(inputs)\n        )\n\n        this.cache.add(node.id, cancellable)\n\n        return cancellable\n      }\n    })\n  }\n\n  private remove(node: Schemes['Node']) {\n    this.getDataflow().remove(node.id)\n  }\n\n  /**\n   * Resets the cache of the node and all its predecessors.\n   * @param nodeId Node id to reset. If not specified, all nodes will be reset.\n   */\n  public reset(nodeId?: NodeId) {\n    if (nodeId) {\n      const setup = this.getDataflow().setups.get(nodeId)\n\n      if (!setup) throw 'setup'\n\n      const outputKeys = setup.outputs()\n\n      this.cache.delete(nodeId)\n      this.editor.getConnections()\n        .filter(c => c.source === nodeId && outputKeys.includes(c.sourceOutput))\n        .forEach(c => this.reset(c.target))\n    } else {\n      this.cache.clear()\n    }\n  }\n\n  /**\n   * Fetches input data for the node by fetching data for all its predecessors recursively.\n   * @param nodeId Node id to fetch input data for\n   * @throws `Cancelled when `reset` is called while fetching data\n   */\n  public async fetchInputs(nodeId: NodeId) {\n    return this.getDataflow().fetchInputs(nodeId)\n  }\n\n  /**\n   * Fetches output data of the node\n   * @param nodeId Node id to fetch data from\n   * @throws `Cancelled` when `reset` is called while fetching data\n   */\n  public async fetch(nodeId: NodeId) {\n    return this.getDataflow().fetch(nodeId)\n  }\n}\n"],"names":["ControlFlow","editor","_classCallCheck","_defineProperty","this","Map","_createClass","key","value","node","setup","setups","get","id","Error","set","nodeId","input","_this","inputKeys","inputs","includes","execute","output","outputs","getConnections","filter","c","source","sourceOutput","forEach","con","target","targetInput","ControlFlowEngine","_Scope","_inherits","_super","_createSuper","configure","call","addPipe","context","type","add","data","remove","scope","_get","_getPrototypeOf","prototype","parentScope","NodeEditor","controlflow","options","Object","keys","forward","String","Scope","Dataflow","_fetch","_fetchInputs","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","result","cons","consWithSourceData","_iterator","_step","_step$value","sourceData","previous","wrap","_context2","prev","next","Promise","all","map","_ref","_callee","_context","t0","fetch","t1","sent","abrupt","stop","_x2","apply","arguments","_createForOfIteratorHelper","s","n","done","concat","_toConsumableArray","err","e","f","_x","_callee3","outputKeys","returningKeys","_this2","_context3","fetchInputs","every","join","_x3","Cache","onDelete","cache","has","item","Array","from","Cancelled","_Error","_wrapNativeSuper","createCancellblePromise","reject","cancelled","commit","promise","res","rej","_len","length","sequence","_key","reduce","p","then","cancel","DataflowEngine","_assertThisInitialized","dataflow","_data","getDataflow","cancellable","_this3","reset","clear"],"mappings":"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"}